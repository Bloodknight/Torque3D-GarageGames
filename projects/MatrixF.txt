Search "MatrixF" (2561 hits in 463 files)
  G:\Torque3D\Engine\source\collision\abstractPolyList.cpp (1 hit)
	Line 73: bool AbstractPolyList::getMapping(MatrixF *, Box3F *)
  G:\Torque3D\Engine\source\collision\abstractPolyList.h (10 hits)
	Line 61:    MatrixF  mBaseMatrix;               // Base transform
	Line 62:    MatrixF  mTransformMatrix;          // Current object transform
	Line 63:    MatrixF  mMatrix;                   // Base * current transform
	Line 77:    void setBaseTransform(const MatrixF& mat);
	Line 84:    void setTransform(const MatrixF* mat, const Point3F& scale);
	Line 91:    void getTransform(MatrixF* mat, Point3F * scale);
	Line 191:    virtual bool getMapping(MatrixF *, Box3F *);
	Line 237: inline void AbstractPolyList::setBaseTransform(const MatrixF& mat)
	Line 242: inline void AbstractPolyList::setTransform(const MatrixF* mat, const Point3F& scale)
	Line 252: inline void AbstractPolyList::getTransform(MatrixF* mat, Point3F * scale)
  G:\Torque3D\Engine\source\collision\boxConvex.cpp (4 hits)
	Line 85: void BoxConvex::getFeatures(const MatrixF& mat,const VectorF& n, ConvexFeature* cf)
	Line 162: void BoxConvex::emitEdge(S32 v1,S32 v2,const MatrixF& mat,ConvexFeature* cf)
	Line 176: void BoxConvex::emitFace(S32 fi,const MatrixF& mat,ConvexFeature* cf)
	Line 210: const MatrixF& OrthoBoxConvex::getTransform() const
  G:\Torque3D\Engine\source\collision\boxConvex.h (5 hits)
	Line 36:    void emitEdge(S32 v1,S32 v2,const MatrixF& mat,ConvexFeature* cf);
	Line 37:    void emitFace(S32 fi,const MatrixF& mat,ConvexFeature* cf);
	Line 47:    void getFeatures(const MatrixF& mat,const VectorF& n, ConvexFeature* cf);
	Line 55:    mutable MatrixF mOrthoMatrixCache;
	Line 60:    virtual const MatrixF& getTransform() const;
  G:\Torque3D\Engine\source\collision\convex.cpp (20 hits)
	Line 70: void CollisionState::set(Convex* a,Convex* b,const MatrixF& a2w, const MatrixF& b2w)
	Line 70: void CollisionState::set(Convex* a,Convex* b,const MatrixF& a2w, const MatrixF& b2w)
	Line 75: F32 CollisionState::distance(const MatrixF& a2w, const MatrixF& b2w, const F32 dontCareDist,
	Line 75: F32 CollisionState::distance(const MatrixF& a2w, const MatrixF& b2w, const F32 dontCareDist,
	Line 76:                        const MatrixF* w2a, const MatrixF* _w2b)
	Line 76:                        const MatrixF* w2a, const MatrixF* _w2b)
	Line 419: void Convex::getFeatures(const MatrixF&,const VectorF&,ConvexFeature* f)
	Line 424: const MatrixF& Convex::getTransform() const
	Line 439: Box3F Convex::getBoundingBox(const MatrixF& mat, const Point3F& scale) const
	Line 503: void Convex::updateStateList(const MatrixF& mat, const Point3F& scale, const Point3F* displacement)
	Line 547: CollisionState* Convex::findClosestState(const MatrixF& mat, const Point3F& scale, const F32 dontCareDist)
	Line 556:    MatrixF axform = mat;
	Line 558:    MatrixF axforminv(true);
	Line 559:    MatrixF temp(mat);
	Line 571:       MatrixF bxform = state->b->getTransform();
	Line 575:       MatrixF bxforminv(true);
	Line 597: bool Convex::getCollisionInfo(const MatrixF& mat, const Point3F& scale, CollisionList* cList,F32 tol)
	Line 626:          MatrixF omat = mat;
	Line 629:          MatrixF imat = omat;
	Line 638:          MatrixF bxform = imat;
  G:\Torque3D\Engine\source\collision\convex.h (12 hits)
	Line 113:    virtual void set(Convex* a,Convex* b,const MatrixF& a2w, const MatrixF& b2w);
	Line 113:    virtual void set(Convex* a,Convex* b,const MatrixF& a2w, const MatrixF& b2w);
	Line 114:    virtual F32 distance(const MatrixF& a2w, const MatrixF& b2w, const F32 dontCareDist,
	Line 114:    virtual F32 distance(const MatrixF& a2w, const MatrixF& b2w, const F32 dontCareDist,
	Line 115:                        const MatrixF* w2a = NULL, const MatrixF* _w2b = NULL);
	Line 115:                        const MatrixF* w2a = NULL, const MatrixF* _w2b = NULL);
	Line 227:    CollisionState* findClosestState(const MatrixF& mat, const Point3F& scale, const F32 dontCareDist = 1);
	Line 237:    void updateStateList(const MatrixF& mat, const Point3F& scale, const Point3F* displacement = NULL);
	Line 250:    virtual const MatrixF& getTransform() const;
	Line 262:    virtual Box3F getBoundingBox(const MatrixF& mat, const Point3F& scale) const;
	Line 275:    virtual void getFeatures(const MatrixF& mat,const VectorF& n, ConvexFeature* cf);
	Line 282:    bool getCollisionInfo(const MatrixF& mat, const Point3F& scale, CollisionList* cList,F32 tol);
  G:\Torque3D\Engine\source\collision\depthSortList.cpp (2 hits)
	Line 104: bool DepthSortList::getMapping(MatrixF * mat, Box3F * box)
	Line 173: void DepthSortList::set(const MatrixF & mat, Point3F & extents)
  G:\Torque3D\Engine\source\collision\depthSortList.h (2 hits)
	Line 86:    void set(const MatrixF & mat, Point3F & extents);
	Line 102:    bool getMapping(MatrixF *, Box3F *);
  G:\Torque3D\Engine\source\collision\gjk.cpp (13 hits)
	Line 204:    const MatrixF& a2w, const MatrixF& b2w)
	Line 204:    const MatrixF& a2w, const MatrixF& b2w)
	Line 223: void GjkCollisionState::reset(const MatrixF& a2w, const MatrixF& b2w)
	Line 223: void GjkCollisionState::reset(const MatrixF& a2w, const MatrixF& b2w)
	Line 235: void GjkCollisionState::getCollisionInfo(const MatrixF& mat, Collision* info)
	Line 274: bool GjkCollisionState::intersect(const MatrixF& a2w, const MatrixF& b2w)
	Line 274: bool GjkCollisionState::intersect(const MatrixF& a2w, const MatrixF& b2w)
	Line 277:    MatrixF w2a,w2b;
	Line 322: F32 GjkCollisionState::distance(const MatrixF& a2w, const MatrixF& b2w,
	Line 322: F32 GjkCollisionState::distance(const MatrixF& a2w, const MatrixF& b2w,
	Line 323:    const F32 dontCareDist, const MatrixF* _w2a, const MatrixF* _w2b)
	Line 323:    const F32 dontCareDist, const MatrixF* _w2a, const MatrixF* _w2b)
	Line 326:    MatrixF w2a,w2b;
  G:\Torque3D\Engine\source\collision\gjk.h (11 hits)
	Line 67:    void reset(const MatrixF& a2w, const MatrixF& b2w);
	Line 67:    void reset(const MatrixF& a2w, const MatrixF& b2w);
	Line 72:    void set(Convex* a,Convex* b,const MatrixF& a2w, const MatrixF& b2w);
	Line 72:    void set(Convex* a,Convex* b,const MatrixF& a2w, const MatrixF& b2w);
	Line 74:    void getCollisionInfo(const MatrixF& mat, Collision* info);
	Line 76:    bool intersect(const MatrixF& a2w, const MatrixF& b2w);
	Line 76:    bool intersect(const MatrixF& a2w, const MatrixF& b2w);
	Line 77:    F32 distance(const MatrixF& a2w, const MatrixF& b2w, const F32 dontCareDist,
	Line 77:    F32 distance(const MatrixF& a2w, const MatrixF& b2w, const F32 dontCareDist,
	Line 78:                        const MatrixF* w2a = NULL, const MatrixF* _w2b = NULL);
	Line 78:                        const MatrixF* w2a = NULL, const MatrixF* _w2b = NULL);
  G:\Torque3D\Engine\source\collision\optimizedPolyList.cpp (3 hits)
	Line 46:    mBaseMatrix       = MatrixF::Identity;
	Line 47:    mMatrix           = MatrixF::Identity;
	Line 48:    mTransformMatrix  = MatrixF::Identity;
  G:\Torque3D\Engine\source\collision\polytope.cpp (1 hit)
	Line 48: void Polytope::buildBox(const MatrixF& transform,const Box3F& box)
  G:\Torque3D\Engine\source\collision\polytope.h (1 hit)
	Line 102:    void buildBox(const MatrixF& transform,const Box3F& box);
  G:\Torque3D\Engine\source\collision\vertexPolyList.cpp (3 hits)
	Line 33:    mBaseMatrix       = MatrixF::Identity;
	Line 34:    mMatrix           = MatrixF::Identity;
	Line 35:    mTransformMatrix  = MatrixF::Identity;
  G:\Torque3D\Engine\source\console\engineTypes.h (1 hit)
	Line 70: ///    <dd>A structured piece of data like a Point3F or MatrixF.  Unlike class instances, structs are directly stored
  G:\Torque3D\Engine\source\console\propertyParsing.cpp (2 hits)
	Line 352:    bool default_scan( const String &data, MatrixF & result )
	Line 366:    bool default_print( String & result, const MatrixF & data )
  G:\Torque3D\Engine\source\console\propertyParsing.h (3 hits)
	Line 38: class MatrixF;
	Line 109:    bool default_scan( const String &data, MatrixF & result );
	Line 110:    bool default_print( String & result, const MatrixF & data );
  G:\Torque3D\Engine\source\core\stream\bitStream.cpp (2 hits)
	Line 453: void BitStream::writeAffineTransform(const MatrixF& matrix)
	Line 470: void BitStream::readAffineTransform(MatrixF* matrix)
  G:\Torque3D\Engine\source\core\stream\bitStream.h (3 hits)
	Line 43: class MatrixF;
	Line 201:    void writeAffineTransform(const MatrixF&);
	Line 202:    void readAffineTransform(MatrixF*);
  G:\Torque3D\Engine\source\core\util\rgb2xyz.cpp (4 hits)
	Line 51:    const MatrixF &rgb2xyz = *((MatrixF *)scRGB2XYZ);
	Line 51:    const MatrixF &rgb2xyz = *((MatrixF *)scRGB2XYZ);
	Line 60:    const MatrixF &xyz2rgb = *((MatrixF *)scXYZ2RGB);
	Line 60:    const MatrixF &xyz2rgb = *((MatrixF *)scXYZ2RGB);
  G:\Torque3D\Engine\source\environment\basicClouds.cpp (2 hits)
	Line 294:    MatrixF xfm(true);
	Line 305:    MatrixF xform(GFX->getProjectionMatrix());
  G:\Torque3D\Engine\source\environment\cloudLayer.cpp (2 hits)
	Line 334:    MatrixF xfm(true);
	Line 347:    MatrixF xform(GFX->getProjectionMatrix());
  G:\Torque3D\Engine\source\environment\decalRoad.cpp (6 hits)
	Line 360:    MatrixF mat(true);
	Line 728:    coreRI.objectToWorld = &MatrixF::Identity;
	Line 731:    MatrixF *tempMat = renderPass->allocUniqueXform( MatrixF( true ) );   
	Line 731:    MatrixF *tempMat = renderPass->allocUniqueXform( MatrixF( true ) );   
	Line 820: void DecalRoad::setTransform( const MatrixF &mat )
	Line 1110:       MatrixF mat( true );
  G:\Torque3D\Engine\source\environment\decalRoad.h (1 hit)
	Line 176:    virtual void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\environment\editors\guiMeshRoadEditorCtrl.cpp (4 hits)
	Line 696:       const MatrixF &mat = mGizmo->getTransform();
	Line 748:    MatrixF mat;
	Line 782:          MatrixF objMat = mSelRoad->getNodeTransform(mSelNode);      
	Line 1138:       MatrixF objMat = mSelRoad->getNodeTransform(mSelNode);      
  G:\Torque3D\Engine\source\environment\editors\guiRiverEditorCtrl.cpp (4 hits)
	Line 723:       const MatrixF &mat = mGizmo->getTransform();
	Line 918:    MatrixF mat;
	Line 952:          MatrixF objMat = mSelRiver->getNodeTransform(mSelNode);      
	Line 1282:       MatrixF objMat = mSelRiver->getNodeTransform(mSelNode);      
  G:\Torque3D\Engine\source\environment\meshRoad.cpp (18 hits)
	Line 264: const MatrixF& MeshRoadConvex::getTransform() const
	Line 266:    return MatrixF::Identity; //mObject->getTransform();    
	Line 274: Box3F MeshRoadConvex::getBoundingBox(const MatrixF& mat, const Point3F& scale) const
	Line 301: void MeshRoadConvex::getFeatures(const MatrixF& mat, const VectorF& n, ConvexFeature* cf)
	Line 376:    //MatrixF i( mObject->getTransform() );
	Line 380:    list->setTransform( &MatrixF::Identity, Point3F::One );
	Line 438: MeshRoadSegment::MeshRoadSegment( MeshRoadSlice *rs0, MeshRoadSlice *rs1, const MatrixF &roadMat )
	Line 826:       coreRI.objectToWorld = &MatrixF::Identity;
	Line 1066:       MatrixF		ObjectMatrix;
	Line 1144: void MeshRoad::setTransform( const MatrixF &mat )
	Line 1293:    polyList->setTransform( &MatrixF::Identity, Point3F::One );
	Line 1332:    MatrixF mat;
	Line 1575:    MatrixF mat( true );
	Line 1672:    MatrixF mat(true);
	Line 1752:             MatrixF::Identity );
	Line 2212: MatrixF MeshRoad::getNodeTransform( U32 idx )
	Line 2214:    MatrixF mat(true);   
	Line 2264: void MeshRoad::calcSliceTransform( U32 idx, MatrixF &mat )
  G:\Torque3D\Engine\source\environment\meshRoad.h (7 hits)
	Line 100:    const MatrixF& getTransform() const;
	Line 102:    Box3F getBoundingBox(const MatrixF& mat, const Point3F& scale) const;
	Line 104:    void getFeatures(const MatrixF& mat,const VectorF& n, ConvexFeature* cf);
	Line 292:    MeshRoadSegment( MeshRoadSlice *rs0, MeshRoadSlice *rs1, const MatrixF &roadMat );   
	Line 458:    virtual void setTransform( const MatrixF &mat );
	Line 493:    MatrixF getNodeTransform( U32 idx );
	Line 494:    void calcSliceTransform( U32 idx, MatrixF &mat );
  G:\Torque3D\Engine\source\environment\river.cpp (10 hits)
	Line 830:    mMatrixSet->setWorld( MatrixF::Identity );
	Line 922:       matParams->set(paramHandles.mModelMatSC, MatrixF::Identity, GFXSCT_Float4x4);
	Line 1048:       MatrixF		ObjectMatrix;
	Line 1159: void River::setTransform( const MatrixF &mat )
	Line 1170:    MatrixF oldMat = getTransform();
	Line 1182:    MatrixF newMat( oldMat );
	Line 1312:    polyList->setTransform( &MatrixF::Identity, Point3F( 1.0f, 1.0f, 1.0f ) );
	Line 1440:    MatrixF mat( true );
	Line 2056: MatrixF River::getNodeTransform( U32 idx ) const
	Line 2058:    MatrixF mat(true);   
  G:\Torque3D\Engine\source\environment\river.h (2 hits)
	Line 402:    virtual void setTransform( const MatrixF &mat );
	Line 442:    MatrixF getNodeTransform( U32 idx ) const;
  G:\Torque3D\Engine\source\environment\scatterSky.cpp (6 hits)
	Line 953:    MatrixF proj( true );
	Line 957:    MatrixF xfm(true);
	Line 960:    MatrixF xform(proj);//GFX->getProjectionMatrix());
	Line 966:       static MatrixF rotMat(EulerF(0.0, 0.0, M_PI_F));
	Line 1066:    mMatrixSet->setWorld( MatrixF::Identity );
	Line 1084:    const MatrixF &camView = state->getCameraTransform();
  G:\Torque3D\Engine\source\environment\skyBox.cpp (4 hits)
	Line 206:    MatrixF worldMat = MatrixF::Identity;
	Line 206:    MatrixF worldMat = MatrixF::Identity;
	Line 237:       MatrixF camPosMat( MatrixF::Identity );
	Line 237:       MatrixF camPosMat( MatrixF::Identity );
  G:\Torque3D\Engine\source\environment\sun.cpp (2 hits)
	Line 464:    //mMatrixSet->setWorld( MatrixF::Identity );
	Line 482:    const MatrixF &camView = state->getCameraTransform();
  G:\Torque3D\Engine\source\environment\VolumetricFog.cpp (6 hits)
	Line 576:    MatrixF mat;
	Line 703:       MatrixF xfm;
	Line 1061:    MatrixF mat = getRenderTransform();
	Line 1071:    MatrixF xform(GFX->getProjectionMatrix());
	Line 1177:    MatrixF mat = getRenderTransform();
	Line 1186:    MatrixF xform(GFX->getProjectionMatrix());
  G:\Torque3D\Engine\source\environment\waterBlock.cpp (5 hits)
	Line 132:       MatrixF objToWorld;
	Line 420:    MatrixF modelMat( getRenderTransform() );
	Line 590: void WaterBlock::setTransform( const MatrixF &mat )
	Line 596:    MatrixF oldMat = mObjToWorld;
	Line 657:       MatrixF mat(true);
  G:\Torque3D\Engine\source\environment\waterBlock.h (1 hit)
	Line 128:    virtual void setTransform( const MatrixF & mat );
  G:\Torque3D\Engine\source\environment\waterObject.cpp (6 hits)
	Line 723:    //MatrixF projMat( true );
	Line 775:    MatrixF proj = GFX->getProjectionMatrix();
	Line 776:    MatrixF newMat(true);
	Line 787:    const MatrixF &camXfm = state->getCameraTransform();
	Line 796:    MatrixF.mul
	Line 1093:       MatrixF mat;      
  G:\Torque3D\Engine\source\environment\waterPlane.cpp (7 hits)
	Line 715:       MatrixF proj( true );
	Line 741:    const MatrixF &objMat = getTransform(); //getRenderTransform();
	Line 742:    const MatrixF &camMat = state->getCameraTransform();
	Line 744:    MatrixF renderMat( true );
	Line 818:       polyList->setTransform( &MatrixF::Identity, Point3F( 1.0f, 1.0f, 1.0f ) );
	Line 862: void WaterPlane::setTransform( const MatrixF &mat )
	Line 866:    MatrixF newMat( true );
  G:\Torque3D\Engine\source\environment\waterPlane.h (1 hit)
	Line 121:    virtual void setTransform( const MatrixF & mat );
  G:\Torque3D\Engine\source\forest\editor\forestSelectionTool.cpp (12 hits)
	Line 41: MatrixF Selection<ForestItem>::getOrientation()
	Line 46:    return MatrixF::Identity;
	Line 61:       const MatrixF &mat = itr->getTransform();
	Line 87:    MatrixF newMat( object.getTransform() );
	Line 98:    MatrixF mat = object.getTransform();
	Line 103:    MatrixF wMat( mat );
	Line 113:       MatrixF transform(EulerF::Zero, -offset);
	Line 114:       transform.mul(MatrixF(delta));
	Line 115:       transform.mul(MatrixF(EulerF::Zero, offset));
	Line 120:       MatrixF transform( delta );
	Line 132:       transform.mul( MatrixF(delta) );
	Line 390:    MatrixF treeMat;
  G:\Torque3D\Engine\source\forest\forest.cpp (1 hit)
	Line 255: void Forest::setTransform( const MatrixF &mat )
  G:\Torque3D\Engine\source\forest\forest.h (1 hit)
	Line 167:    void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\forest\forestCell.cpp (2 hits)
	Line 260:                                           const MatrixF &xfm,
	Line 487:                                           MatrixF::Identity ) )
  G:\Torque3D\Engine\source\forest\forestCell.h (1 hit)
	Line 187:                                  const MatrixF &xfm,
  G:\Torque3D\Engine\source\forest\forestCollision.cpp (5 hits)
	Line 80: void ForestConvex::calculateTransform( const MatrixF &worldXfrm )
	Line 92: Box3F ForestConvex::getBoundingBox(const MatrixF& mat, const Point3F& scale) const
	Line 124: void ForestConvex::getFeatures( const MatrixF &mat, const VectorF &n, ConvexFeature *cf )
	Line 291:    MatrixF xfm = getTransform();
	Line 418:    MatrixF mat = getTransform();
  G:\Torque3D\Engine\source\forest\forestCollision.h (5 hits)
	Line 64:    void           calculateTransform( const MatrixF &worldXfrm );
	Line 65:    const MatrixF& getTransform() const { return mTransform; }
	Line 67:    Box3F          getBoundingBox( const MatrixF &mat, const Point3F &scale) const;
	Line 69:    void           getFeatures( const MatrixF &mat, const VectorF &n, ConvexFeature *cf );
	Line 82:    MatrixF mTransform;
  G:\Torque3D\Engine\source\forest\forestDataFile.cpp (4 hits)
	Line 137:    MatrixF xfm;
	Line 310:    MatrixF xfm;
	Line 321:                                        const MatrixF &xfm,
	Line 334:                                           const MatrixF &newXfm,
  G:\Torque3D\Engine\source\forest\forestDataFile.h (2 hits)
	Line 107:                                  const MatrixF &xfm,
	Line 113:                                     const MatrixF &newXfm,
  G:\Torque3D\Engine\source\forest\forestItem.cpp (1 hit)
	Line 228: void ForestItem::setTransform( const MatrixF &xfm, F32 scale )
  G:\Torque3D\Engine\source\forest\forestItem.h (3 hits)
	Line 163:    MatrixF mTransform;
	Line 207:    const MatrixF& getTransform() const { return mTransform; }
	Line 215:    void setTransform( const MatrixF &xfm, F32 scale );
  G:\Torque3D\Engine\source\forest\forestRender.cpp (1 hit)
	Line 274:    MatrixF projBias(true);
  G:\Torque3D\Engine\source\forest\forestWindEmitter.cpp (3 hits)
	Line 306:    MatrixF xfm;
	Line 466: void ForestWindEmitter::setTransform( const MatrixF &mat )
	Line 565:    MatrixF mat( true ); 
  G:\Torque3D\Engine\source\forest\forestWindEmitter.h (1 hit)
	Line 199:    virtual void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\forest\ts\tsForestItemData.cpp (1 hit)
	Line 241:    MatrixF worldMat = item.getTransform();
  G:\Torque3D\Engine\source\forest\windDeformation.cpp (1 hit)
	Line 104:       MatrixF invXfm( item->getTransform() );
  G:\Torque3D\Engine\source\gfx\D3D11\gfxD3D11Device.cpp (1 hit)
	Line 790:    MatrixF tempMatrix =  mProjectionMatrix * mViewMatrix * mWorldMatrix[mWorldStackSize];  
  G:\Torque3D\Engine\source\gfx\D3D11\gfxD3D11Device.h (2 hits)
	Line 86:    MatrixF mTempMatrix;    ///< Temporary matrix, no assurances on value at all
	Line 163:    virtual void setMatrix( GFXMatrixType /*mtype*/, const MatrixF &/*mat*/ ) { };
  G:\Torque3D\Engine\source\gfx\D3D11\gfxD3D11Shader.cpp (7 hits)
	Line 147:    // passed in is a MatrixF ( which is will be ), we DO NOT have a
	Line 159:    // This "cute" bit of code allows us to support 2x3 and 3x3 matrices in shader constants but use our MatrixF class.  Yes, a hack. -BTR
	Line 238:          currSourcePointer += sizeof(MatrixF);
	Line 473: void GFXD3D11ShaderConstBuffer::set(GFXShaderConstHandle* handle, const MatrixF& mat, const GFXShaderConstType matrixType) 
	Line 483:    MatrixF transposed;   
	Line 501: void GFXD3D11ShaderConstBuffer::set(GFXShaderConstHandle* handle, const MatrixF* mat, const U32 arraySize, const GFXShaderConstType matrixType)
	Line 511:    static Vector<MatrixF> transposed;
  G:\Torque3D\Engine\source\gfx\D3D11\gfxD3D11Shader.h (2 hits)
	Line 340:    virtual void set(GFXShaderConstHandle* handle, const MatrixF& mat, const GFXShaderConstType matType = GFXSCT_Float4x4);
	Line 341:    virtual void set(GFXShaderConstHandle* handle, const MatrixF* mat, const U32 arraySize, const GFXShaderConstType matrixType = GFXSCT_Float4x4);
  G:\Torque3D\Engine\source\gfx\D3D9\gfxD3D9Device.cpp (1 hit)
	Line 200:    MatrixF tempMatrix = mProjectionMatrix * mViewMatrix * mWorldMatrix[mWorldStackSize];
  G:\Torque3D\Engine\source\gfx\D3D9\gfxD3D9Device.h (1 hit)
	Line 116:    MatrixF mTempMatrix;    ///< Temporary matrix, no assurances on value at all
  G:\Torque3D\Engine\source\gfx\D3D9\gfxD3D9Shader.cpp (5 hits)
	Line 209:          currSourcePointer += sizeof(MatrixF);
	Line 383: void GFXD3D9ShaderConstBuffer::set(GFXShaderConstHandle* handle, const MatrixF& mat, const GFXShaderConstType matrixType) 
	Line 393:    MatrixF transposed;   
	Line 411: void GFXD3D9ShaderConstBuffer::set(GFXShaderConstHandle* handle, const MatrixF* mat, const U32 arraySize, const GFXShaderConstType matrixType)
	Line 421:    static Vector<MatrixF> transposed;
  G:\Torque3D\Engine\source\gfx\D3D9\gfxD3D9Shader.h (2 hits)
	Line 154:    virtual void set(GFXShaderConstHandle* handle, const MatrixF& mat, const GFXShaderConstType matType = GFXSCT_Float4x4);
	Line 155:    virtual void set(GFXShaderConstHandle* handle, const MatrixF* mat, const U32 arraySize, const GFXShaderConstType matrixType = GFXSCT_Float4x4);
  G:\Torque3D\Engine\source\gfx\D3D9\pc\gfxPCD3D9Device.cpp (1 hit)
	Line 565: void GFXPCD3D9Device::setMatrix( GFXMatrixType mtype, const MatrixF &mat ) 
  G:\Torque3D\Engine\source\gfx\D3D9\pc\gfxPCD3D9Device.h (1 hit)
	Line 64:    virtual void setMatrix( GFXMatrixType mtype, const MatrixF &mat );
  G:\Torque3D\Engine\source\gfx\genericConstBuffer.cpp (3 hits)
	Line 77:    // passed in is a MatrixF ( which is will be ), we DO NOT have a
	Line 89:    // This "cute" bit of code allows us to support 2x3 and 3x3 matrices in shader constants but use our MatrixF class.  Yes, a hack. -BTR
	Line 118:    // We're generic, so just copy the full MatrixF in
  G:\Torque3D\Engine\source\gfx\genericConstBuffer.h (4 hits)
	Line 189:    inline void set( const GenericConstBufferLayout::ParamDesc& pd, const MatrixF& mat, const GFXShaderConstType matrixType )
	Line 196:       internalSet( pd, matrixType, sizeof(MatrixF), &mat );
	Line 199:    inline void set( const GenericConstBufferLayout::ParamDesc& pd, const MatrixF* mat, const U32 arraySize, const GFXShaderConstType matrixType )
	Line 206:       internalSet( pd, matrixType, sizeof(MatrixF)*arraySize, mat );
  G:\Torque3D\Engine\source\gfx\gfxDevice.cpp (3 hits)
	Line 657:    MatrixF projection;
	Line 668:    MatrixF projection;
	Line 697:    MatrixF projection;
  G:\Torque3D\Engine\source\gfx\gfxDevice.h (23 hits)
	Line 290:    MatrixF mStereoEyeTransforms[NumStereoPorts];
	Line 291:    MatrixF mInverseStereoEyeTransforms[NumStereoPorts];
	Line 353:    const MatrixF* getStereoEyeTransforms() { return mStereoEyeTransforms; }
	Line 354:    const MatrixF* getInverseStereoEyeTransforms() { return mInverseStereoEyeTransforms; }
	Line 359:    void setStereoEyeTransforms(MatrixF *transforms) { dMemcpy(mStereoEyeTransforms, transforms, sizeof(mStereoEyeTransforms)); dMemcpy(mInverseStereoEyeTransforms, transforms, sizeof(mInverseStereoEyeTransforms)); mInverseStereoEyeTransforms[0].inverse(); mInverseStereoEyeTransforms[1].inverse();  }
	Line 560:    MatrixF mWorldMatrix[WORLD_STACK_MAX];
	Line 564:    MatrixF mProjectionMatrix;
	Line 567:    MatrixF mViewMatrix;
	Line 570:    MatrixF mTextureMatrix[TEXTURE_STAGE_COUNT];
	Line 626:    virtual void setMatrix( GFXMatrixType mtype, const MatrixF &mat ) = 0;
	Line 966:    void setWorldMatrix( const MatrixF &newWorld );
	Line 969:    inline const MatrixF &getWorldMatrix() const { return mWorldMatrix[mWorldStackSize]; }
	Line 980:    void setProjectionMatrix( const MatrixF &newProj );
	Line 983:    inline const MatrixF &getProjectionMatrix() const { return mProjectionMatrix; }
	Line 987:    void setViewMatrix( const MatrixF &newView );
	Line 990:    inline const MatrixF &getViewMatrix() const { return mViewMatrix; }
	Line 995:    void multWorld( const MatrixF &mat );
	Line 998:    void setTextureMatrix( const U32 stage, const MatrixF &texMat );
	Line 1099: inline void GFXDevice::setWorldMatrix( const MatrixF &newWorld )
	Line 1123: inline void GFXDevice::multWorld( const MatrixF &mat )
	Line 1130: inline void GFXDevice::setProjectionMatrix( const MatrixF &newProj )
	Line 1137: inline void GFXDevice::setViewMatrix( const MatrixF &newView )
	Line 1144: inline void GFXDevice::setTextureMatrix( const U32 stage, const MatrixF &texMat )
  G:\Torque3D\Engine\source\gfx\gfxDrawUtil.cpp (29 hits)
	Line 568:       MatrixF rotMatrix( EulerF( 0.0, 0.0, spinAngle ) );
	Line 634: void GFXDrawUtil::drawSphere( const GFXStateBlockDesc &desc, F32 radius, const Point3F &pos, const ColorI &color, bool drawTop, bool drawBottom, const MatrixF *xfm )
	Line 636:    MatrixF mat;
	Line 640:       mat = MatrixF::Identity;
	Line 705: void GFXDrawUtil::drawTriangle( const GFXStateBlockDesc &desc, const Point3F &p0, const Point3F &p1, const Point3F &p2, const ColorI &color, const MatrixF *xfm )
	Line 713: void GFXDrawUtil::_drawWireTriangle( const GFXStateBlockDesc &desc, const Point3F &p0, const Point3F &p1, const Point3F &p2, const ColorI &color, const MatrixF *xfm )
	Line 746: void GFXDrawUtil::_drawSolidTriangle( const GFXStateBlockDesc &desc, const Point3F &p0, const Point3F &p1, const Point3F &p2, const ColorI &color, const MatrixF *xfm )
	Line 777: void GFXDrawUtil::drawPolygon( const GFXStateBlockDesc& desc, const Point3F* points, U32 numPoints, const ColorI& color, const MatrixF* xfm /* = NULL */ )
	Line 815: void GFXDrawUtil::drawCube( const GFXStateBlockDesc &desc, const Box3F &box, const ColorI &color, const MatrixF *xfm )
	Line 820: void GFXDrawUtil::drawCube( const GFXStateBlockDesc &desc, const Point3F &size, const Point3F &pos, const ColorI &color, const MatrixF *xfm )
	Line 828: void GFXDrawUtil::_drawWireCube( const GFXStateBlockDesc &desc, const Point3F &size, const Point3F &pos, const ColorI &color, const MatrixF *xfm )
	Line 871: void GFXDrawUtil::_drawSolidCube( const GFXStateBlockDesc &desc, const Point3F &size, const Point3F &pos, const ColorI &color, const MatrixF *xfm )
	Line 935: void GFXDrawUtil::drawPolyhedron( const GFXStateBlockDesc &desc, const AnyPolyhedron &poly, const ColorI &color, const MatrixF *xfm )
	Line 943: void GFXDrawUtil::_drawWirePolyhedron( const GFXStateBlockDesc &desc, const AnyPolyhedron &poly, const ColorI &color, const MatrixF *xfm )
	Line 988: void GFXDrawUtil::_drawSolidPolyhedron( const GFXStateBlockDesc &desc, const AnyPolyhedron &poly, const ColorI &color, const MatrixF *xfm )
	Line 1079: void GFXDrawUtil::drawObjectBox( const GFXStateBlockDesc &desc, const Point3F &size, const Point3F &pos, const MatrixF &objMat, const ColorI &color )
	Line 1085:    MatrixF scaledObjMat( true );
	Line 1142: void GFXDrawUtil::drawCapsule( const GFXStateBlockDesc &desc, const Point3F &center, F32 radius, F32 height, const ColorI &color, const MatrixF *xfm )
	Line 1150: void GFXDrawUtil::_drawSolidCapsule( const GFXStateBlockDesc &desc, const Point3F &center, F32 radius, F32 height, const ColorI &color, const MatrixF *xfm )
	Line 1152:    MatrixF mat;
	Line 1156:       mat = MatrixF::Identity;
	Line 1191:    MatrixF sphereMat;
	Line 1196:       sphereMat = MatrixF::Identity;   
	Line 1211: void GFXDrawUtil::_drawWireCapsule( const GFXStateBlockDesc &desc, const Point3F &center, F32 radius, F32 height, const ColorI &color, const MatrixF *xfm )
	Line 1213:    MatrixF mat;
	Line 1217:       mat = MatrixF::Identity;
	Line 1258:    MatrixF mat( true );
	Line 1329:    MatrixF mat( true );
	Line 1595: void GFXDrawUtil::drawTransform( const GFXStateBlockDesc &desc, const MatrixF &mat, const Point3F *scale, const ColorI colors[3] )
  G:\Torque3D\Engine\source\gfx\gfxDrawUtil.h (18 hits)
	Line 109:    void drawTriangle( const GFXStateBlockDesc &desc, const Point3F &p0, const Point3F &p1, const Point3F &p2, const ColorI &color, const MatrixF *xfm = NULL );
	Line 110:    void drawPolygon( const GFXStateBlockDesc& desc, const Point3F* points, U32 numPoints, const ColorI& color, const MatrixF* xfm = NULL );
	Line 111:    void drawCube( const GFXStateBlockDesc &desc, const Point3F &size, const Point3F &pos, const ColorI &color, const MatrixF *xfm = NULL );   
	Line 112:    void drawCube( const GFXStateBlockDesc &desc, const Box3F &box, const ColorI &color, const MatrixF *xfm = NULL );   
	Line 113:    void drawObjectBox( const GFXStateBlockDesc &desc, const Point3F &size, const Point3F &pos, const MatrixF &objMat, const ColorI &color );   
	Line 114:    void drawSphere( const GFXStateBlockDesc &desc, F32 radius, const Point3F &pos, const ColorI &color, bool drawTop = true, bool drawBottom = true, const MatrixF *xfm = NULL );      
	Line 115:    void drawCapsule( const GFXStateBlockDesc &desc, const Point3F &center, F32 radius, F32 height, const ColorI &color, const MatrixF *xfm = NULL );
	Line 127:    void drawPolyhedron( const GFXStateBlockDesc &desc, const AnyPolyhedron &poly, const ColorI &color, const MatrixF *xfm = NULL );
	Line 143:    /// If scale is NULL axes will be drawn the length they exist within the MatrixF.
	Line 145:    void drawTransform( const GFXStateBlockDesc &desc, const MatrixF &mat, const Point3F *scale = NULL, const ColorI colors[3] = NULL );  
	Line 150:    void _drawWireTriangle( const GFXStateBlockDesc &desc, const Point3F &p0, const Point3F &p1, const Point3F &p2, const ColorI &color, const MatrixF *xfm = NULL );
	Line 151:    void _drawSolidTriangle( const GFXStateBlockDesc &desc, const Point3F &p0, const Point3F &p1, const Point3F &p2, const ColorI &color, const MatrixF *xfm = NULL );
	Line 152:    void _drawWireCube( const GFXStateBlockDesc &desc, const Point3F &size, const Point3F &pos, const ColorI &color, const MatrixF *xfm = NULL );
	Line 153:    void _drawSolidCube( const GFXStateBlockDesc &desc, const Point3F &size, const Point3F &pos, const ColorI &color, const MatrixF *xfm = NULL );
	Line 154:    void _drawWireCapsule( const GFXStateBlockDesc &desc, const Point3F &center, F32 radius, F32 height, const ColorI &color, const MatrixF *xfm = NULL );
	Line 155:    void _drawSolidCapsule( const GFXStateBlockDesc &desc, const Point3F &center, F32 radius, F32 height, const ColorI &color, const MatrixF *xfm = NULL );
	Line 156:    void _drawWirePolyhedron( const GFXStateBlockDesc &desc, const AnyPolyhedron &poly, const ColorI &color, const MatrixF *xfm = NULL );
	Line 157:    void _drawSolidPolyhedron( const GFXStateBlockDesc &desc, const AnyPolyhedron &poly, const ColorI &color, const MatrixF *xfm = NULL );
  G:\Torque3D\Engine\source\gfx\gfxFence.cpp (1 hit)
	Line 85:    GFX->setWorldMatrix( MatrixF::Identity );
  G:\Torque3D\Engine\source\gfx\gfxFontRenderBatcher.cpp (1 hit)
	Line 66:    MatrixF rotMatrix;
  G:\Torque3D\Engine\source\gfx\gfxShader.h (3 hits)
	Line 63: class MatrixF;
	Line 195:                      const MatrixF& mat, 
	Line 201:                      const MatrixF* mat, 
  G:\Torque3D\Engine\source\gfx\gfxTransformSaver.h (3 hits)
	Line 78:    MatrixF mSavedProjectionMatrix, mSavedViewMatrix;
	Line 139:    const MatrixF& getProjectionMatrix() const { return mSavedProjectionMatrix; }
	Line 142:    const MatrixF& getViewMatrix() const { return mSavedViewMatrix; }
  G:\Torque3D\Engine\source\gfx\gl\gfxGLDevice.cpp (4 hits)
	Line 682: void GFXGLDevice::setMatrix( GFXMatrixType mtype, const MatrixF &mat )
	Line 723:    static MatrixF translate(true);
	Line 731:    MatrixF mTempMatrix(true);
	Line 838:    MatrixF tempMatrix =  mProjectionMatrix * mViewMatrix * mWorldMatrix[mWorldStackSize];  
  G:\Torque3D\Engine\source\gfx\gl\gfxGLDevice.h (3 hits)
	Line 183:    virtual void setMatrix( GFXMatrixType mtype, const MatrixF &mat );
	Line 227:    MatrixF m_mCurrentWorld;
	Line 228:    MatrixF m_mCurrentView;
  G:\Torque3D\Engine\source\gfx\gl\gfxGLShader.cpp (5 hits)
	Line 279: void GFXGLShaderConstBuffer::set(GFXShaderConstHandle* handle, const MatrixF& mat, const GFXShaderConstType matType)
	Line 312:          MatrixF transposed;   
	Line 314:          dMemcpy( mInstPtr + _glHandle->mOffset, (const F32*)transposed, sizeof(MatrixF) );
	Line 318:       dMemcpy(mBuffer + _glHandle->mOffset, (const F32*)mat, sizeof(MatrixF));
	Line 327: void GFXGLShaderConstBuffer::set(GFXShaderConstHandle* handle, const MatrixF* mat, const U32 arraySize, const GFXShaderConstType matrixType)
  G:\Torque3D\Engine\source\gfx\gl\gfxGLShader.h (2 hits)
	Line 137:    virtual void set(GFXShaderConstHandle* handle, const MatrixF& mat, const GFXShaderConstType matType = GFXSCT_Float4x4);
	Line 138:    virtual void set(GFXShaderConstHandle* handle, const MatrixF* mat, const U32 arraySize, const GFXShaderConstType matrixType = GFXSCT_Float4x4);   
  G:\Torque3D\Engine\source\gfx\Null\gfxNullDevice.h (1 hit)
	Line 113:    virtual void setMatrix( GFXMatrixType mtype, const MatrixF &mat ) { };
  G:\Torque3D\Engine\source\gfx\screenshot.cpp (2 hits)
	Line 85:    GFX->setWorldMatrix( MatrixF::Identity );
	Line 90:    MatrixF tileMat( true );
  G:\Torque3D\Engine\source\gfx\sim\debugDraw.cpp (1 hit)
	Line 403: void DebugDrawer::drawPolyhedronDebugInfo( const AnyPolyhedron& polyhedron, const MatrixF& transform, const Point3F& scale )
  G:\Torque3D\Engine\source\gfx\sim\debugDraw.h (1 hit)
	Line 141:    void drawPolyhedronDebugInfo( const AnyPolyhedron& polyhedron, const MatrixF& transform, const Point3F& scale );
  G:\Torque3D\Engine\source\gui\3d\guiTSControl.cpp (9 hits)
	Line 407:       MatrixF myTransforms[2];
	Line 461:       MatrixF rotMat(EulerF(0, 0, mDegToRad(mCameraZRot)));
	Line 509:       GFX->setViewMatrix(MatrixF::Identity);
	Line 550:    MatrixF worldToCamera = mLastCameraQuery.cameraMatrix;
	Line 575:       MatrixF proj(1);
	Line 580:       const MatrixF *eyeTransforms = GFX->getStereoEyeTransforms();
	Line 590:          MatrixF eyeWorldTrans(1);
	Line 592:          MatrixF eyeWorld(1);
	Line 597:          GFX->setViewMatrix(MatrixF::Identity);
  G:\Torque3D\Engine\source\gui\3d\guiTSControl.h (6 hits)
	Line 50:    MatrixF     eyeTransforms[2];
	Line 54:    MatrixF     cameraMatrix;
	Line 91:    MatrixF     mSaveModelview;
	Line 92:    MatrixF     mSaveProjection;
	Line 129:    const MatrixF& getLastWorldMatrix() const { return mSaveModelview; }
	Line 132:    const MatrixF& getLastProjectionMatrix() const { return mSaveProjection; }
  G:\Torque3D\Engine\source\gui\controls\guiMaterialCtrl.cpp (1 hit)
	Line 139:    MatrixF cameraMatrix( true );
  G:\Torque3D\Engine\source\gui\core\guiCanvas.cpp (3 hits)
	Line 1835:    GFX->setWorldMatrix( MatrixF::Identity );
	Line 1836:    GFX->setViewMatrix( MatrixF::Identity );
	Line 1837:    GFX->setProjectionMatrix( MatrixF::Identity );
  G:\Torque3D\Engine\source\gui\core\guiOffscreenCanvas.cpp (3 hits)
	Line 176:    GFX->setWorldMatrix( MatrixF::Identity );
	Line 177:    GFX->setViewMatrix( MatrixF::Identity );
	Line 178:    GFX->setProjectionMatrix( MatrixF::Identity );
  G:\Torque3D\Engine\source\gui\editor\guiShapeEdPreview.cpp (12 hits)
	Line 584:                MatrixF hubMat;
	Line 733:       MatrixF xRot, zRot;
	Line 816:    MatrixF camRotMatrix( smCamMatrix );
	Line 855:       MatrixF orientation( true );
	Line 867:          MatrixF mat( true );
	Line 1020:                   mModel->mNodeTransforms[mSelectedNode].mul( MatrixF( rot ) );
	Line 1122: bool GuiShapeEdPreview::getCameraTransform(MatrixF* cameraMatrix)
	Line 1128:       MatrixF xRot, zRot;
	Line 1393:       GFX->setWorldMatrix( MatrixF::Identity );
	Line 1475:          mGizmo->set( MatrixF::Identity, pos, Point3F::One);
	Line 1603:       const MatrixF& nodeMat = mModel->mNodeTransforms[mSelectedNode];
	Line 1652:       polylist.setTransform( &MatrixF::Identity, Point3F::One );
  G:\Torque3D\Engine\source\gui\editor\guiShapeEdPreview.h (2 hits)
	Line 64:       MatrixF              mTransform; //!< Mount offset transform
	Line 242:    bool getCameraTransform(MatrixF* cameraMatrix);
  G:\Torque3D\Engine\source\gui\editor\inspector\mountingGroup.cpp (1 hit)
	Line 374: 					target->mountObject(mTargetEntity, nodeIdx, MatrixF::Identity);
  G:\Torque3D\Engine\source\gui\worldEditor\editor.cpp (1 hit)
	Line 50:       mBookmarks[i] = MatrixF(true);
  G:\Torque3D\Engine\source\gui\worldEditor\editor.h (1 hit)
	Line 60:       MatrixF mBookmarks[10];
  G:\Torque3D\Engine\source\gui\worldEditor\editTSCtrl.cpp (12 hits)
	Line 54: MatrixF  EditTSCtrl::smCamMatrix;
	Line 731:             MatrixF mat(EulerF(0, 0, rot));
	Line 888:    static MatrixF sRotMat(EulerF( (M_PI_F / -2.0f), 0.0f, 0.0f));
	Line 890:    MatrixF camMat = mLastCameraQuery.cameraMatrix;
	Line 894:    MatrixF axis;
	Line 1049: bool EditTSCtrl::getCameraTransform(MatrixF* cameraMatrix)
	Line 1083:          MatrixF camRot(true);
	Line 1157:                MatrixF angle(EulerF(mIsoCamAngle, 0, 0));
	Line 1158:                MatrixF rot(mIsoCamRot);
	Line 1213:    MatrixF camera = GFX->getWorldMatrix();
	Line 1234:    MatrixF camera = GFX->getWorldMatrix();
	Line 1271:    MatrixF mat;
  G:\Torque3D\Engine\source\gui\worldEditor\editTSCtrl.h (2 hits)
	Line 153:       static MatrixF    smCamMatrix;
	Line 173:       virtual bool getCameraTransform(MatrixF* cameraMatrix);
  G:\Torque3D\Engine\source\gui\worldEditor\gizmo.cpp (15 hits)
	Line 373: void Gizmo::set( const MatrixF &objMat, const Point3F &worldPos, const Point3F &objScale )
	Line 498:          MatrixF worldToGizmo = mTransform;
	Line 976:          //MatrixF mat = mObjectMat;
	Line 1108:          //   MatrixF mat;
	Line 1118:          //MatrixF rotMat( mDeltaTotalRot );
	Line 1135:          //   MatrixF m0;
	Line 1155:          MatrixF rotMat( mDeltaTotalRot );
	Line 1162:             MatrixF mat0 = mCurrentTransform;
	Line 1169:             MatrixF mat1 = mCurrentTransform;
	Line 1171:             MatrixF mrot;
	Line 1189: void Gizmo::renderGizmo(const MatrixF &cameraTransform, F32 cameraFOV )
	Line 1418: void Gizmo::renderText( const RectI &viewPort, const MatrixF &modelView, const MatrixF &projection )
	Line 1418: void Gizmo::renderText( const RectI &viewPort, const MatrixF &modelView, const MatrixF &projection )
	Line 1622:    MatrixF cameraXfm = GFX->getWorldMatrix();   
	Line 1722:       MatrixF worldToGizmo = mTransform;
  G:\Torque3D\Engine\source\gui\worldEditor\gizmo.h (14 hits)
	Line 156: // The Gizmo has a MatrixF transform and Point3F scale on which it will
	Line 199:    void set( const MatrixF &objMat, const Point3F &worldPos, const Point3F &objScale ); 
	Line 215:    const MatrixF& getTransform() const       { return mCurrentTransform; }
	Line 292:    void renderGizmo( const MatrixF &cameraTransform, F32 camerFOV = 1.5f );
	Line 297:    void renderText( const RectI &viewPort, const MatrixF &modelView, const MatrixF &projection );
	Line 297:    void renderText( const RectI &viewPort, const MatrixF &modelView, const MatrixF &projection );
	Line 335:    MatrixF mObjectMat;
	Line 336:    MatrixF mObjectMatInv;
	Line 337:    MatrixF mTransform;
	Line 338:    MatrixF mCurrentTransform;
	Line 339:    MatrixF mSavedTransform;
	Line 344:    MatrixF mCameraMat;
	Line 403:    MatrixF mLastWorldMat;
	Line 404:    MatrixF mLastProjMat;
  G:\Torque3D\Engine\source\gui\worldEditor\guiConvexShapeEditorCtrl.cpp (39 hits)
	Line 237:       const MatrixF &surf = mConvexSEL->mSurfaces[mFaceSEL];
	Line 239:       MatrixF newSurf( surf );
	Line 241:       MatrixF rotMat( EulerF( 0.0f, mDegToRad( 2.0f ), 0.0f ) );
	Line 475:       MatrixF rotMat( (EulerF)rot );
	Line 477:       MatrixF worldToObj( mConvexSEL->getTransform() );
	Line 482:       MatrixF &newSurf = mConvexSEL->mSurfaces.last();
	Line 557:             const MatrixF &gMat = mGizmo->getTransform();      
	Line 558:             MatrixF surfMat;
	Line 561:             MatrixF worldToObj ( mConvexSEL->getTransform() );
	Line 821:                MatrixF objToSurf( mConvexSEL->mSurfaces[ mFaceSEL ] );
	Line 908:          const MatrixF &objMat = mConvexSEL->getTransform();
	Line 966:          MatrixF objToWorld( mConvexSEL->getTransform() );
	Line 1024:    MatrixF renderMat( shape->getTransform() );
	Line 1073:    const MatrixF &surfToObj = shape->mSurfaces[ face.id ];
	Line 1074:    MatrixF objToSurf( surfToObj );
	Line 1114:    MatrixF worldToObj( shape->getTransform() );
	Line 1144:       MatrixF &curSurface = shape->mSurfaces[ curFace.id ];
	Line 1301:          MatrixF surfMat = mConvexSEL->getSurfaceWorldMat( mFaceSEL );  
	Line 1303:          MatrixF objToWorld( mConvexSEL->getTransform() );
	Line 1612:       MatrixF worldToObj( shape->getTransform() );
	Line 1623: void GuiConvexEditorCtrl::cleanMatrix( MatrixF &mat )
	Line 1695:    Vector< MatrixF > tempSurfaces;   
	Line 1697:    MatrixF tempObjToWorld( object->getTransform() );
	Line 1761:       MatrixF objMat( true );
	Line 1896:       MatrixF worldToObj( mTransform );
	Line 1932:    MatrixF xfm( mTransform );
	Line 1964:    Vector< MatrixF > &inShapeSurfaces = inShape->getSurfaces();
	Line 1968:    MatrixF inShapeToWorld( inShape->getTransform() );
	Line 1970:    //MatrixF inWorldToShape( inShapeToWorld );
	Line 1973:    MatrixF shapeToWorld;
	Line 1978:    MatrixF worldToShape( shapeToWorld );
	Line 1981:    MatrixF inShapeToNewShape;
	Line 1987:    Vector< MatrixF > &shapeSurfaces = newShape->getSurfaces();
	Line 2026:       MatrixF &surf = shapeSurfaces[i+2];
	Line 2059:       MatrixF &inwardFace = faceShape->mSurfaces[1];
	Line 2060:       //MatrixF &outwardFace = faceShape->mSurfaces[0];      
	Line 2142:    MatrixF rotMat( true );
	Line 2145:    MatrixF &dstMat = mConvexSEL->mSurfaces.last();   
	Line 2146:    const MatrixF &srcMat = mConvexSEL->mSurfaces[mFaceSEL];
  G:\Torque3D\Engine\source\gui\worldEditor\guiConvexShapeEditorCtrl.h (8 hits)
	Line 103:    void cleanMatrix( MatrixF &mat );
	Line 120:       MatrixF getCameraMat() const { return mLastCameraQuery.cameraMatrix; }
	Line 168:    MatrixF mFaceSavedXfm;
	Line 171:    Vector< MatrixF > mSavedSurfaces;
	Line 172:    Vector< MatrixF > mLastValidShape;
	Line 212:    Vector< MatrixF > mSavedSurfaces;
	Line 213:    MatrixF mSavedObjToWorld;
	Line 285:    MatrixF mTransform;
  G:\Torque3D\Engine\source\gui\worldEditor\guiDecalEditorCtrl.cpp (5 hits)
	Line 386:       const MatrixF &gizmoMat = mGizmo->getTransform();
	Line 523:       MatrixF worldMat( true );
	Line 538:       MatrixF worldMat( true );
	Line 568:    MatrixF worldMat( true );
	Line 893:    MatrixF worldMat( true );
  G:\Torque3D\Engine\source\gui\worldEditor\guiMissionArea.cpp (1 hit)
	Line 512:    const MatrixF & terrMat = mTerrainBlock->getTransform();
  G:\Torque3D\Engine\source\gui\worldEditor\guiTerrPreviewCtrl.cpp (1 hit)
	Line 229: 	MatrixF matrix = query.cameraMatrix;
  G:\Torque3D\Engine\source\gui\worldEditor\terrainEditor.cpp (2 hits)
	Line 921:    const MatrixF & mat = gPoint.terrainBlock->getTransform();
	Line 1577:       const MatrixF & mat = mActiveTerrain->getTransform();
  G:\Torque3D\Engine\source\gui\worldEditor\tSelection.h (2 hits)
	Line 41:    MatrixF getOrientation() { return MatrixF(); }
	Line 41:    MatrixF getOrientation() { return MatrixF(); }
  G:\Torque3D\Engine\source\gui\worldEditor\worldEditor.cpp (31 hits)
	Line 142:       MatrixF mat = obj->getTransform();
	Line 246:    EulerF extractEuler(const MatrixF & matrix)
	Line 251:       r.x = mAsin(mat[MatrixF::idx(2,1)]);
	Line 255:          r.y = mAtan2(-mat[MatrixF::idx(2,0)], mat[MatrixF::idx(2,2)]);
	Line 255:          r.y = mAtan2(-mat[MatrixF::idx(2,0)], mat[MatrixF::idx(2,2)]);
	Line 256:          r.z = mAtan2(-mat[MatrixF::idx(0,1)], mat[MatrixF::idx(1,1)]);
	Line 256:          r.z = mAtan2(-mat[MatrixF::idx(0,1)], mat[MatrixF::idx(1,1)]);
	Line 261:          r.z = mAtan2(mat[MatrixF::idx(1,0)], mat[MatrixF::idx(0,0)]);
	Line 261:          r.z = mAtan2(mat[MatrixF::idx(1,0)], mat[MatrixF::idx(0,0)]);
	Line 298: void WorldEditor::setClientObjInfo(SceneObject * obj, const MatrixF & mat, const VectorF & scale)
	Line 368:    MatrixF oldMatrix;
	Line 831:          MatrixF mat = MathUtils::createOrientFromDir(ri.normal);
	Line 832:          MatrixF rotMat(rot);
	Line 995:          MatrixF mat = MathUtils::createOrientFromDir(foundPlane.getNormal());
	Line 996:          MatrixF rotMat(rot);
	Line 1017:          MatrixF mat = object->getTransform();
	Line 1225:    MatrixF objMat = obj->getTransform();
	Line 1288:    MatrixF mat = obj->getTransform();
	Line 2344:    MatrixF                 mStandardMat;
	Line 2396:       MatrixF cameraMat = GFX->getWorldMatrix();
	Line 2447:          MatrixF objMat(true);
	Line 3159:       MatrixF mat(true);
	Line 3544:    MatrixF orientation;
	Line 3654:    MatrixF fabMat(true);
	Line 3658:    MatrixF objMat;
	Line 3766:    MatrixF xfm = objB->getTransform();   
	Line 3767:    MatrixF mat = objA->getWorldTransform();
	Line 3771:    MatrixF temp = objA->getTransform();
	Line 3809:    MatrixF savedTransform = geometryProvider->getTransform();
	Line 3812:    geometryProvider->setTransform( MatrixF::Identity );
	Line 3954:       MatrixF orientation( true );
  G:\Torque3D\Engine\source\gui\worldEditor\worldEditor.h (2 hits)
	Line 123:       static void setClientObjInfo(SceneObject *, const MatrixF &, const VectorF &);
	Line 140:             MatrixF     mMatrix;
  G:\Torque3D\Engine\source\gui\worldEditor\worldEditorSelection.cpp (19 hits)
	Line 210:       const MatrixF & mat = obj->getTransform();
	Line 300:       MatrixF mat = obj->getTransform();
	Line 354: void WorldEditorSelection::orient(const MatrixF & rot, const Point3F & center)
	Line 363:       MatrixF mat = rot;
	Line 381:          MatrixF mat = object->getTransform();
	Line 383:          MatrixF transform(rot);
	Line 400:          MatrixF mat = object->getTransform();
	Line 407:          MatrixF wMat = object->getWorldTransform();
	Line 411:          MatrixF transform(EulerF(0,0,0), -offset);
	Line 412:          transform.mul(MatrixF(rot));
	Line 413:          transform.mul(MatrixF(EulerF(0,0,0), offset));
	Line 427:          MatrixF mat = object->getTransform();
	Line 435:          MatrixF transform(rot);
	Line 439:          MatrixF wMat = object->getWorldTransform();
	Line 449:          transform.mul(MatrixF(rot));
	Line 473:       MatrixF mat = object->getTransform();
	Line 477:       MatrixF rmat(rot);
	Line 537:       MatrixF mat = object->getTransform();
	Line 573:       MatrixF mat = object->getTransform();
  G:\Torque3D\Engine\source\gui\worldEditor\worldEditorSelection.h (3 hits)
	Line 66:       MatrixF mTransform;
	Line 106:       const MatrixF& getTransform();
	Line 113:       void orient(const MatrixF &, const Point3F &);
  G:\Torque3D\Engine\source\lighting\advanced\advancedLightBinManager.cpp (6 hits)
	Line 263:    const MatrixF &worldToCameraXfm = matrixSet.getWorldToCamera();
	Line 448:    MatrixF invCam( frustum.getTransform() );
	Line 475:       MatrixF camTrans = frustum.getTransform();
	Line 531:    data.objTrans = &MatrixF::Identity;
	Line 553:          MatrixF scaleRotateTranslate( EulerF( M_PI_F / -2.0f, 0.0f, 0.0f ) );
	Line 666: void AdvancedLightBinManager::LightMaterialInfo::setLightParameters( const LightInfo *lightInfo, const SceneRenderState* renderState, const MatrixF &worldViewOnly )
  G:\Torque3D\Engine\source\lighting\advanced\advancedLightBinManager.h (2 hits)
	Line 179:       void setLightParameters( const LightInfo *light, const SceneRenderState* renderState, const MatrixF &worldViewOnly );
	Line 201:    MatrixF mLightMat;
  G:\Torque3D\Engine\source\lighting\advanced\advancedLightManager.cpp (2 hits)
	Line 425:          MatrixF proj;
	Line 465:          MatrixF proj;
  G:\Torque3D\Engine\source\lighting\common\blobShadow.cpp (1 hit)
	Line 330:    MatrixF world = GFX->getWorldMatrix();
  G:\Torque3D\Engine\source\lighting\common\blobShadow.h (2 hits)
	Line 38:    MatrixF mLightToWorld;
	Line 39:    MatrixF mWorldToLight;
  G:\Torque3D\Engine\source\lighting\common\projectedShadow.cpp (3 hits)
	Line 169:    const MatrixF &renderTransform = mParentObject->getRenderTransform();
	Line 176:       MatrixF t( renderTransform );   
	Line 278:    static MatrixF sRotMat(EulerF( 0.0f, -(M_PI_F/2.0f), 0.0f));
  G:\Torque3D\Engine\source\lighting\common\projectedShadow.h (1 hit)
	Line 68:    MatrixF mWorldToLight;
  G:\Torque3D\Engine\source\lighting\lightInfo.cpp (3 hits)
	Line 178: void LightInfo::getWorldToLightProj( MatrixF *outMatrix ) const
	Line 185:       MatrixF proj;
	Line 188:       MatrixF light = getTransform();
  G:\Torque3D\Engine\source\lighting\lightInfo.h (4 hits)
	Line 124:    MatrixF mTransform;
	Line 166:    const MatrixF& getTransform() const { return mTransform; }
	Line 167:    void setTransform( const MatrixF &xfm ) { mTransform = xfm; }
	Line 233:    void getWorldToLightProj( MatrixF *outMatrix ) const;
  G:\Torque3D\Engine\source\lighting\shadowMap\cubeLightShadowMap.cpp (1 hit)
	Line 161:       MatrixF lightMatrix(true);
  G:\Torque3D\Engine\source\lighting\shadowMap\dualParaboloidLightShadowMap.cpp (3 hits)
	Line 90:       MatrixF temp = mLight->getTransform();
	Line 100:       MatrixF temp = mLight->getTransform();
	Line 151:       MatrixF temp = mLight->getTransform();
  G:\Torque3D\Engine\source\lighting\shadowMap\lightShadowMap.cpp (3 hits)
	Line 162: void LightShadowMap::calcLightMatrices( MatrixF &outLightMatrix, const Frustum &viewFrustum )
	Line 180:          MatrixF lightMatrix = MathUtils::createOrientFromDir(mLight->getDirection());
	Line 182:          static MatrixF rotMat(EulerF( (M_PI_F / 2.0f), 0.0f, 0.0f));
  G:\Torque3D\Engine\source\lighting\shadowMap\lightShadowMap.h (3 hits)
	Line 195:    const MatrixF& getWorldToLightProj() const { return mWorldToLightProj; }
	Line 260:    MatrixF mWorldToLightProj;
	Line 275:    void calcLightMatrices( MatrixF& outLightMatrix, const Frustum &viewFrustum );
  G:\Torque3D\Engine\source\lighting\shadowMap\pssmLightShadowMap.cpp (12 hits)
	Line 132: Box3F PSSMLightShadowMap::_calcClipSpaceAABB(const Frustum& f, const MatrixF& transform, F32 farDist)
	Line 163: void PSSMLightShadowMap::_roundProjection(const MatrixF& lightMat, const MatrixF& cropMatrix, Point3F &offset, U32 splitNum)
	Line 163: void PSSMLightShadowMap::_roundProjection(const MatrixF& lightMat, const MatrixF& cropMatrix, Point3F &offset, U32 splitNum)
	Line 166:    MatrixF currentProj = GFX->getProjectionMatrix();
	Line 228:    MatrixF lightMatrix;
	Line 231:    MatrixF lightViewProj = GFX->getProjectionMatrix() * lightMatrix;
	Line 240:    MatrixF toLightSpace = lightMatrix; // * invCurrentView;
	Line 286:       MatrixF cropMatrix(true);
	Line 318:       MatrixF alightProj = GFX->getProjectionMatrix();
	Line 348:       MatrixF camera = GFX->getWorldMatrix();
	Line 494:    MatrixF lightFarPlaneMat(true);
	Line 495:    MatrixF invLightFarPlaneMat(true);
  G:\Torque3D\Engine\source\lighting\shadowMap\pssmLightShadowMap.h (3 hits)
	Line 58:    Box3F _calcClipSpaceAABB(const Frustum& f, const MatrixF& transform, F32 farDist);
	Line 60:    void _roundProjection(const MatrixF& lightMat, const MatrixF& cropMatrix, Point3F &offset, U32 splitNum);
	Line 60:    void _roundProjection(const MatrixF& lightMat, const MatrixF& cropMatrix, Point3F &offset, U32 splitNum);
  G:\Torque3D\Engine\source\lighting\shadowMap\singleLightShadowMap.cpp (2 hits)
	Line 69:    MatrixF lightMatrix;
	Line 74:    const MatrixF& lightProj = GFX->getProjectionMatrix();
  G:\Torque3D\Engine\source\materials\materialParameters.h (2 hits)
	Line 89:    virtual void set(MaterialParameterHandle* handle, const MatrixF& mat, const GFXShaderConstType matrixType = GFXSCT_Float4x4) {}
	Line 90:    virtual void set(MaterialParameterHandle* handle, const MatrixF* mat, const U32 arraySize, const GFXShaderConstType matrixType = GFXSCT_Float4x4) {}
  G:\Torque3D\Engine\source\materials\matInstance.cpp (2 hits)
	Line 208: void MatInstParameters::set(MaterialParameterHandle* handle, const MatrixF& mat, const GFXShaderConstType matrixType)
	Line 215: void MatInstParameters::set(MaterialParameterHandle* handle, const MatrixF* mat, const U32 arraySize, const GFXShaderConstType matrixType)
  G:\Torque3D\Engine\source\materials\matInstance.h (2 hits)
	Line 172:    virtual void set(MaterialParameterHandle* handle, const MatrixF& mat, const GFXShaderConstType matrixType = GFXSCT_Float4x4);
	Line 173:    virtual void set(MaterialParameterHandle* handle, const MatrixF* mat, const U32 arraySize, const GFXShaderConstType matrixType = GFXSCT_Float4x4);
  G:\Torque3D\Engine\source\materials\processedCustomMaterial.cpp (2 hits)
	Line 456:    MatrixF result(true);
	Line 516:             setMaterialParameter<MatrixF>(ret, handle, field->value);
  G:\Torque3D\Engine\source\materials\processedFFMaterial.cpp (4 hits)
	Line 248: void ProcessedFFMaterial::_setPrimaryLightInfo(const MatrixF &_objTrans, LightInfo* light, U32 pass)
	Line 271:    MatrixF objTrans = _objTrans;
	Line 289: void ProcessedFFMaterial::_setSecondaryLightInfo(const MatrixF &_objTrans, LightInfo* light)
	Line 292:    MatrixF objTrans = _objTrans;
  G:\Torque3D\Engine\source\materials\processedFFMaterial.h (2 hits)
	Line 113:    virtual void _setPrimaryLightInfo(const MatrixF &objTrans, LightInfo* light, U32 pass);
	Line 116:    virtual void _setSecondaryLightInfo(const MatrixF &objTrans, LightInfo* light);
  G:\Torque3D\Engine\source\materials\processedShaderMaterial.cpp (5 hits)
	Line 869:       MatrixF texMat( true );
	Line 906:             MatrixF test( true );
	Line 918:             MatrixF test( true );
	Line 934:          MatrixF temp( true );
	Line 1244:       MatrixF tempMat( *sgData.objTrans );
  G:\Torque3D\Engine\source\materials\processedShaderMaterial.h (1 hit)
	Line 261:    void _setPrimaryLightConst(const LightInfo* light, const MatrixF& objTrans, const U32 stageNum);
  G:\Torque3D\Engine\source\materials\sceneData.h (3 hits)
	Line 83:    const MatrixF *objTrans;
	Line 99:       objTrans = &MatrixF::Identity;
	Line 111:       objTrans = &MatrixF::Identity;
  G:\Torque3D\Engine\source\materials\shaderMaterialParameters.cpp (2 hits)
	Line 199: void ShaderMaterialParameters::set(MaterialParameterHandle* handle, const MatrixF& mat, const GFXShaderConstType matrixType)
	Line 214: void ShaderMaterialParameters::set(MaterialParameterHandle* handle, const MatrixF* mat, const U32 arraySize, const GFXShaderConstType matrixType)
  G:\Torque3D\Engine\source\materials\shaderMaterialParameters.h (2 hits)
	Line 89:    virtual void set(MaterialParameterHandle* handle, const MatrixF& mat, const GFXShaderConstType matrixType = GFXSCT_Float4x4);
	Line 90:    virtual void set(MaterialParameterHandle* handle, const MatrixF* mat, const U32 arraySize, const GFXShaderConstType matrixType = GFXSCT_Float4x4);
  G:\Torque3D\Engine\source\math\mAngAxis.cpp (9 hits)
	Line 38: AngAxisF & AngAxisF::set( const MatrixF & mat )
	Line 45: MatrixF * AngAxisF::setMatrix( MatrixF * mat ) const
	Line 45: MatrixF * AngAxisF::setMatrix( MatrixF * mat ) const
	Line 51: void AngAxisF::RotateX(F32 angle, MatrixF * mat)
	Line 58: void AngAxisF::RotateY(F32 angle, MatrixF * mat)
	Line 65: void AngAxisF::RotateZ(F32 angle, MatrixF * mat)
	Line 75:    MatrixF mat;
	Line 83:    MatrixF mat;
	Line 91:    MatrixF mat;
  G:\Torque3D\Engine\source\math\mAngAxis.h (9 hits)
	Line 30: class MatrixF;
	Line 44:    explicit AngAxisF( const MatrixF &m );
	Line 48:    AngAxisF& set( const MatrixF & m );
	Line 54:    MatrixF * setMatrix( MatrixF * mat ) const;
	Line 54:    MatrixF * setMatrix( MatrixF * mat ) const;
	Line 56:    static void RotateX(F32 angle, MatrixF * mat);
	Line 57:    static void RotateY(F32 angle, MatrixF * mat);
	Line 58:    static void RotateZ(F32 angle, MatrixF * mat);
	Line 77: inline AngAxisF::AngAxisF( const MatrixF & mat )
  G:\Torque3D\Engine\source\math\mathIO.h (2 hits)
	Line 125: inline bool mathRead(Stream& stream, MatrixF* m)
	Line 253: inline bool mathWrite(Stream& stream, const MatrixF& m)
  G:\Torque3D\Engine\source\math\mathTypes.cpp (21 hits)
	Line 96: IMPLEMENT_STRUCT( MatrixF,
	Line 97:    MatrixF, MathTypes,
	Line 307: ConsoleType(MatrixF, TypeMatrixF, MatrixF, "")
	Line 307: ConsoleType(MatrixF, TypeMatrixF, MatrixF, "")
	Line 308: ImplementConsoleTypeCasters( TypeMatrixF, MatrixF )
	Line 315:    MatrixF* mat = ( MatrixF* ) dptr;
	Line 315:    MatrixF* mat = ( MatrixF* ) dptr;
	Line 332:       Con::errorf( "MatrixF must be set as \"c0x c0y c0z c1x c1y c1z c2x c2y c2z\"" );
	Line 340:    MatrixF* mat = ( MatrixF* ) dptr;
	Line 340:    MatrixF* mat = ( MatrixF* ) dptr;
	Line 350: ConsoleType(MatrixPosition, TypeMatrixPosition, MatrixF, "")
	Line 385: ConsoleType(MatrixRotation, TypeMatrixRotation, MatrixF, "")
	Line 389:    AngAxisF aa(*(MatrixF *) dptr);
	Line 417:    MatrixF temp;
	Line 420:    F32* pDst = *(MatrixF *)dptr;
	Line 966: DefineConsoleFunction( VectorOrthoBasis, MatrixF, ( AngAxisF aa ),,
	Line 972:    MatrixF mat;
	Line 1072:    MatrixF m1 = left.getMatrix();
	Line 1073:    MatrixF m2 = right.getMatrix();
	Line 1091:    MatrixF m = transform.getMatrix();
	Line 1106:    MatrixF m = transform.getMatrix();
  G:\Torque3D\Engine\source\math\mathTypes.h (5 hits)
	Line 41: class MatrixF;
	Line 58: DECLARE_STRUCT( MatrixF );
	Line 74: DefineConsoleType( TypeMatrixF, MatrixF )
	Line 75: DefineConsoleType( TypeMatrixPosition, MatrixF)
	Line 76: DefineConsoleType( TypeMatrixRotation, MatrixF )
  G:\Torque3D\Engine\source\math\mathUtils.cpp (27 hits)
	Line 182: void getZBiasProjectionMatrix( F32 bias, const Frustum &frustum, MatrixF *outMat, bool rotate )
	Line 191: MatrixF createOrientFromDir( const Point3F &direction )
	Line 207:    MatrixF mat( true );
	Line 217: void getMatrixFromUpVector( const VectorF &up, MatrixF *outMat )
	Line 236: void getMatrixFromForwardVector( const VectorF &forward, MatrixF *outMat  )
	Line 258:    MatrixF orient = createOrientFromDir( axis );
	Line 272:    MatrixF temp(true);
	Line 353:    MatrixF  mat( rot );
	Line 356:    MatrixF   mat2( rot );
	Line 366: void transformBoundingBox(const Box3F &sbox, const MatrixF &mat, const Point3F scale, Box3F &dbox)
	Line 415:                               const MatrixF &world, 
	Line 416:                               const MatrixF &projection )
	Line 418:    MatrixF worldProjection = projection;
	Line 429:                               const MatrixF &worldProjection )
	Line 461:                               const MatrixF &world, 
	Line 462:                               const MatrixF &projection, 
	Line 466:    MatrixF invWorldProjection = projection;
	Line 1121: void sortQuadWindingOrder( const MatrixF &quadMat, bool clockwise, const Point3F *verts, U32 *vertMap, U32 count )
	Line 1170: void buildMatrix( const VectorF *rvec, const VectorF *fvec, const VectorF *uvec, const VectorF *pos, MatrixF *outMat )
	Line 1399: void makeProjection( MatrixF *outMatrix, 
	Line 1419:    const MatrixF &transform)
	Line 1441: static const MatrixF sGFXProjRotMatrix( EulerF( (M_PI_F / 2.0f), 0.0f, 0.0f ) );
	Line 1443: void makeProjection( MatrixF *outMatrix, 
	Line 1485: void makeOrthoProjection(  MatrixF *outMatrix, 
	Line 1654: bool clipFrustumByPolygon( const Point3F* points, U32 numPoints, const RectI& viewport, const MatrixF& world,
	Line 1655:                            const MatrixF& projection, const Frustum& inFrustum, const Frustum& rootFrustum, Frustum& outFrustum )
	Line 1707:    MatrixF worldProjection = projection;
  G:\Torque3D\Engine\source\math\mathUtils.h (19 hits)
	Line 102:    void getZBiasProjectionMatrix( F32 bias, const Frustum &frustum, MatrixF *outMat, bool rotate = true );
	Line 105:    MatrixF createOrientFromDir( const Point3F &direction );
	Line 113:    void getMatrixFromUpVector( const VectorF &up, MatrixF *outMat );   
	Line 121:    void getMatrixFromForwardVector( const VectorF &forward, MatrixF *outMat );   
	Line 177:    void transformBoundingBox(const Box3F &sbox, const MatrixF &mat, const Point3F scale, Box3F &dbox);
	Line 182:                                  const MatrixF &world, 
	Line 183:                                  const MatrixF &projection );
	Line 187:                                  const MatrixF &worldProjection );
	Line 192:                                  const MatrixF &world, 
	Line 193:                                  const MatrixF &projection, 
	Line 215:                                  const MatrixF& world,
	Line 216:                                  const MatrixF& projection,
	Line 299: 	void sortQuadWindingOrder( const MatrixF &quadMat, bool clockwise, const Point3F *verts, U32 *vertMap, U32 count );
	Line 319:    void buildMatrix( const VectorF *rvec, const VectorF *fvec, const VectorF *uvec, const VectorF *pos, MatrixF *outMat );
	Line 338:                              const MatrixF &transform = MatrixF(1) );
	Line 338:                              const MatrixF &transform = MatrixF(1) );
	Line 342:    void makeProjection( MatrixF *outMatrix, 
	Line 351:    void makeProjection( MatrixF *outMatrix, 
	Line 362:    void makeOrthoProjection(  MatrixF *outMatrix, 
  G:\Torque3D\Engine\source\math\mBox.cpp (1 hit)
	Line 110: bool Box3F::collideOrientedBox(const Point3F & bRadii, const MatrixF & toA) const
  G:\Torque3D\Engine\source\math\mBox.h (2 hits)
	Line 39: class MatrixF;
	Line 173:       bool collideOrientedBox( const Point3F &radii, const MatrixF &toUs ) const;
  G:\Torque3D\Engine\source\math\mIntersector.h (3 hits)
	Line 124:       void _preprocess( const MatrixF& objToWorld, const Point3F& scale );
	Line 144:                                 const MatrixF& objToWorld,
	Line 158: void PolyhedronBoxIntersector< Polyhedron >::_preprocess( const MatrixF& objToWorld, const Point3F& scale )
  G:\Torque3D\Engine\source\math\mMath_C.cpp (41 hits)
	Line 473:    AssertFatal( det != 0.0f, "MatrixF::inverse: non-singular matrix, no inverse.");
	Line 517:    AssertFatal( det != 0.0f, "MatrixF::inverse: non-singular matrix, no inverse.");
	Line 733:    MatrixF invScale(true);
	Line 735:    pScaleElems[MatrixF::idx(0, 0)] = 1.0f / s[0];
	Line 736:    pScaleElems[MatrixF::idx(1, 1)] = 1.0f / s[1];
	Line 737:    pScaleElems[MatrixF::idx(2, 2)] = 1.0f / s[2];
	Line 739:    const Point3F shear( m[MatrixF::idx(3, 0)], m[MatrixF::idx(3, 1)], m[MatrixF::idx(3, 2)] );
	Line 739:    const Point3F shear( m[MatrixF::idx(3, 0)], m[MatrixF::idx(3, 1)], m[MatrixF::idx(3, 2)] );
	Line 739:    const Point3F shear( m[MatrixF::idx(3, 0)], m[MatrixF::idx(3, 1)], m[MatrixF::idx(3, 2)] );
	Line 741:    const Point3F row0(m[MatrixF::idx(0, 0)], m[MatrixF::idx(0, 1)], m[MatrixF::idx(0, 2)]);
	Line 741:    const Point3F row0(m[MatrixF::idx(0, 0)], m[MatrixF::idx(0, 1)], m[MatrixF::idx(0, 2)]);
	Line 741:    const Point3F row0(m[MatrixF::idx(0, 0)], m[MatrixF::idx(0, 1)], m[MatrixF::idx(0, 2)]);
	Line 742:    const Point3F row1(m[MatrixF::idx(1, 0)], m[MatrixF::idx(1, 1)], m[MatrixF::idx(1, 2)]);
	Line 742:    const Point3F row1(m[MatrixF::idx(1, 0)], m[MatrixF::idx(1, 1)], m[MatrixF::idx(1, 2)]);
	Line 742:    const Point3F row1(m[MatrixF::idx(1, 0)], m[MatrixF::idx(1, 1)], m[MatrixF::idx(1, 2)]);
	Line 743:    const Point3F row2(m[MatrixF::idx(2, 0)], m[MatrixF::idx(2, 1)], m[MatrixF::idx(2, 2)]);
	Line 743:    const Point3F row2(m[MatrixF::idx(2, 0)], m[MatrixF::idx(2, 1)], m[MatrixF::idx(2, 2)]);
	Line 743:    const Point3F row2(m[MatrixF::idx(2, 0)], m[MatrixF::idx(2, 1)], m[MatrixF::idx(2, 2)]);
	Line 749:    MatrixF invTrMatrix(true);
	Line 751:    destMat[MatrixF::idx(0, 0)] = m[MatrixF::idx(0, 0)];
	Line 751:    destMat[MatrixF::idx(0, 0)] = m[MatrixF::idx(0, 0)];
	Line 752:    destMat[MatrixF::idx(1, 0)] = m[MatrixF::idx(1, 0)];
	Line 752:    destMat[MatrixF::idx(1, 0)] = m[MatrixF::idx(1, 0)];
	Line 753:    destMat[MatrixF::idx(2, 0)] = m[MatrixF::idx(2, 0)];
	Line 753:    destMat[MatrixF::idx(2, 0)] = m[MatrixF::idx(2, 0)];
	Line 754:    destMat[MatrixF::idx(0, 1)] = m[MatrixF::idx(0, 1)];
	Line 754:    destMat[MatrixF::idx(0, 1)] = m[MatrixF::idx(0, 1)];
	Line 755:    destMat[MatrixF::idx(1, 1)] = m[MatrixF::idx(1, 1)];
	Line 755:    destMat[MatrixF::idx(1, 1)] = m[MatrixF::idx(1, 1)];
	Line 756:    destMat[MatrixF::idx(2, 1)] = m[MatrixF::idx(2, 1)];
	Line 756:    destMat[MatrixF::idx(2, 1)] = m[MatrixF::idx(2, 1)];
	Line 757:    destMat[MatrixF::idx(0, 2)] = m[MatrixF::idx(0, 2)];
	Line 757:    destMat[MatrixF::idx(0, 2)] = m[MatrixF::idx(0, 2)];
	Line 758:    destMat[MatrixF::idx(1, 2)] = m[MatrixF::idx(1, 2)];
	Line 758:    destMat[MatrixF::idx(1, 2)] = m[MatrixF::idx(1, 2)];
	Line 759:    destMat[MatrixF::idx(2, 2)] = m[MatrixF::idx(2, 2)];
	Line 759:    destMat[MatrixF::idx(2, 2)] = m[MatrixF::idx(2, 2)];
	Line 760:    destMat[MatrixF::idx(0, 3)] = A;
	Line 761:    destMat[MatrixF::idx(1, 3)] = B;
	Line 762:    destMat[MatrixF::idx(2, 3)] = C;
	Line 770:    MatrixF temp;
  G:\Torque3D\Engine\source\math\mMatrix.cpp (14 hits)
	Line 30: const MatrixF MatrixF::Identity( true );
	Line 30: const MatrixF MatrixF::Identity( true );
	Line 34: void MatrixF::transposeTo(F32 *matrix) const
	Line 54: bool MatrixF::isAffine() const
	Line 110: bool MatrixF::fullInverse()
	Line 161: EulerF MatrixF::toEuler() const
	Line 166:    r.x = mAsin(mClampF(mat[MatrixF::idx(2,1)], -1.0, 1.0));
	Line 170:       r.y = mAtan2(-mat[MatrixF::idx(2,0)], mat[MatrixF::idx(2,2)]);
	Line 170:       r.y = mAtan2(-mat[MatrixF::idx(2,0)], mat[MatrixF::idx(2,2)]);
	Line 171:       r.z = mAtan2(-mat[MatrixF::idx(0,1)], mat[MatrixF::idx(1,1)]);
	Line 171:       r.z = mAtan2(-mat[MatrixF::idx(0,1)], mat[MatrixF::idx(1,1)]);
	Line 176:       r.z = mAtan2(mat[MatrixF::idx(1,0)], mat[MatrixF::idx(0,0)]);
	Line 176:       r.z = mAtan2(mat[MatrixF::idx(1,0)], mat[MatrixF::idx(0,0)]);
	Line 182: void MatrixF::dumpMatrix(const char *caption /* =NULL */) const
  G:\Torque3D\Engine\source\math\mMatrix.h (113 hits)
	Line 42: class MatrixF
	Line 51:    explicit MatrixF(bool identity=false);
	Line 55:    explicit MatrixF( const EulerF &e);
	Line 59:    MatrixF( const EulerF &e, const Point3F& p);
	Line 70:    MatrixF& set( const EulerF &e);
	Line 73:    MatrixF& set( const EulerF &e, const Point3F& p);
	Line 76:    MatrixF& setCrossProduct( const Point3F &p);
	Line 79:    MatrixF& setTensorProduct( const Point3F &p, const Point3F& q);
	Line 88:    MatrixF& identity();
	Line 91:    MatrixF& inverse();
	Line 93:    void invertTo( MatrixF *out );
	Line 97:    MatrixF& affineInverse();           
	Line 100:    MatrixF& transpose();
	Line 103:    MatrixF& scale( const Point3F &s );            
	Line 104:    MatrixF& scale( F32 s ) { return scale( Point3F( s, s, s ) ); }
	Line 193:    MatrixF&  mul(const MatrixF &a);                    ///< M * a -> M
	Line 193:    MatrixF&  mul(const MatrixF &a);                    ///< M * a -> M
	Line 194:    MatrixF&  mulL(const MatrixF &a);                   ///< a * M -> M
	Line 194:    MatrixF&  mulL(const MatrixF &a);                   ///< a * M -> M
	Line 195:    MatrixF&  mul(const MatrixF &a, const MatrixF &b);  ///< a * b -> M
	Line 195:    MatrixF&  mul(const MatrixF &a, const MatrixF &b);  ///< a * b -> M
	Line 195:    MatrixF&  mul(const MatrixF &a, const MatrixF &b);  ///< a * b -> M
	Line 198:    MatrixF&  mul(const F32 a);                         ///< M * a -> M
	Line 199:    MatrixF&  mul(const MatrixF &a, const F32 b);       ///< a * b -> M
	Line 199:    MatrixF&  mul(const MatrixF &a, const F32 b);       ///< a * b -> M
	Line 210:    MatrixF& add( const MatrixF& m );
	Line 210:    MatrixF& add( const MatrixF& m );
	Line 220:    friend MatrixF operator * ( const MatrixF &m1, const MatrixF &m2 );
	Line 220:    friend MatrixF operator * ( const MatrixF &m1, const MatrixF &m2 );
	Line 220:    friend MatrixF operator * ( const MatrixF &m1, const MatrixF &m2 );
	Line 221:    MatrixF& operator *= ( const MatrixF &m );
	Line 221:    MatrixF& operator *= ( const MatrixF &m );
	Line 224:    const static MatrixF Identity;
	Line 231: inline MatrixF::MatrixF(bool _identity)
	Line 231: inline MatrixF::MatrixF(bool _identity)
	Line 237: inline MatrixF::MatrixF( const EulerF &e )
	Line 237: inline MatrixF::MatrixF( const EulerF &e )
	Line 242: inline MatrixF::MatrixF( const EulerF &e, const Point3F& p )
	Line 242: inline MatrixF::MatrixF( const EulerF &e, const Point3F& p )
	Line 247: inline MatrixF& MatrixF::set( const EulerF &e)
	Line 247: inline MatrixF& MatrixF::set( const EulerF &e)
	Line 254: inline MatrixF& MatrixF::set( const EulerF &e, const Point3F& p)
	Line 254: inline MatrixF& MatrixF::set( const EulerF &e, const Point3F& p)
	Line 260: inline MatrixF& MatrixF::setCrossProduct( const Point3F &p)
	Line 260: inline MatrixF& MatrixF::setCrossProduct( const Point3F &p)
	Line 271: inline MatrixF& MatrixF::setTensorProduct( const Point3F &p, const Point3F &q)
	Line 271: inline MatrixF& MatrixF::setTensorProduct( const Point3F &p, const Point3F &q)
	Line 287: inline bool MatrixF::isIdentity() const
	Line 308: inline MatrixF& MatrixF::identity()
	Line 308: inline MatrixF& MatrixF::identity()
	Line 330: inline MatrixF& MatrixF::inverse()
	Line 330: inline MatrixF& MatrixF::inverse()
	Line 336: inline void MatrixF::invertTo( MatrixF *out )
	Line 336: inline void MatrixF::invertTo( MatrixF *out )
	Line 341: inline MatrixF& MatrixF::affineInverse()
	Line 341: inline MatrixF& MatrixF::affineInverse()
	Line 348: inline MatrixF& MatrixF::transpose()
	Line 348: inline MatrixF& MatrixF::transpose()
	Line 354: inline MatrixF& MatrixF::scale(const Point3F& p)
	Line 354: inline MatrixF& MatrixF::scale(const Point3F& p)
	Line 360: inline Point3F MatrixF::getScale() const
	Line 369: inline void MatrixF::normalize()
	Line 374: inline MatrixF& MatrixF::mul( const MatrixF &a )
	Line 374: inline MatrixF& MatrixF::mul( const MatrixF &a )
	Line 374: inline MatrixF& MatrixF::mul( const MatrixF &a )
	Line 376:    AssertFatal(&a != this, "MatrixF::mul - a.mul(a) is invalid!");
	Line 378:    MatrixF tempThis(*this);
	Line 383: inline MatrixF& MatrixF::mulL( const MatrixF &a )
	Line 383: inline MatrixF& MatrixF::mulL( const MatrixF &a )
	Line 383: inline MatrixF& MatrixF::mulL( const MatrixF &a )
	Line 385:    AssertFatal(&a != this, "MatrixF::mulL - a.mul(a) is invalid!");
	Line 387:    MatrixF tempThis(*this);
	Line 392: inline MatrixF& MatrixF::mul( const MatrixF &a, const MatrixF &b )
	Line 392: inline MatrixF& MatrixF::mul( const MatrixF &a, const MatrixF &b )
	Line 392: inline MatrixF& MatrixF::mul( const MatrixF &a, const MatrixF &b )
	Line 392: inline MatrixF& MatrixF::mul( const MatrixF &a, const MatrixF &b )
	Line 394:    AssertFatal((&a != this) && (&b != this), "MatrixF::mul - a.mul(a, b) a.mul(b, a) a.mul(a, a) is invalid!");
	Line 401: inline MatrixF& MatrixF::mul(const F32 a)
	Line 401: inline MatrixF& MatrixF::mul(const F32 a)
	Line 410: inline MatrixF& MatrixF::mul(const MatrixF &a, const F32 b)
	Line 410: inline MatrixF& MatrixF::mul(const MatrixF &a, const F32 b)
	Line 410: inline MatrixF& MatrixF::mul(const MatrixF &a, const F32 b)
	Line 418: inline void MatrixF::mul( Point4F& p ) const
	Line 425: inline void MatrixF::mulP( Point3F& p) const
	Line 433: inline void MatrixF::mulP( const Point3F &p, Point3F *d) const
	Line 439: inline void MatrixF::mulV( VectorF& v) const
	Line 447: inline void MatrixF::mulV( const VectorF &v, Point3F *d) const
	Line 453: inline void MatrixF::mul(Box3F& b) const
	Line 458: inline MatrixF& MatrixF::add( const MatrixF& a )
	Line 458: inline MatrixF& MatrixF::add( const MatrixF& a )
	Line 458: inline MatrixF& MatrixF::add( const MatrixF& a )
	Line 466: inline void MatrixF::getColumn(S32 col, Point4F *cptr) const
	Line 474: inline void MatrixF::getColumn(S32 col, Point3F *cptr) const
	Line 481: inline void MatrixF::setColumn(S32 col, const Point4F &cptr)
	Line 489: inline void MatrixF::setColumn(S32 col, const Point3F &cptr)
	Line 497: inline void MatrixF::getRow(S32 col, Point4F *cptr) const
	Line 506: inline void MatrixF::getRow(S32 col, Point3F *cptr) const
	Line 514: inline void MatrixF::setRow(S32 col, const Point4F &cptr)
	Line 523: inline void MatrixF::setRow(S32 col, const Point3F &cptr)
	Line 531: inline Point3F MatrixF::getPosition() const
	Line 536: inline void MatrixF::displace( const Point3F &delta )
	Line 543: inline VectorF MatrixF::getForwardVector() const
	Line 550: inline VectorF MatrixF::getRightVector() const
	Line 557: inline VectorF MatrixF::getUpVector() const
	Line 567: inline MatrixF operator * ( const MatrixF &m1, const MatrixF &m2 )
	Line 567: inline MatrixF operator * ( const MatrixF &m1, const MatrixF &m2 )
	Line 567: inline MatrixF operator * ( const MatrixF &m1, const MatrixF &m2 )
	Line 570:    MatrixF temp;
	Line 575: inline MatrixF& MatrixF::operator *= ( const MatrixF &m1 )
	Line 575: inline MatrixF& MatrixF::operator *= ( const MatrixF &m1 )
	Line 575: inline MatrixF& MatrixF::operator *= ( const MatrixF &m1 )
	Line 577:    MatrixF tempThis(*this);
	Line 586: inline void mTransformPlane(const MatrixF& mat, const Point3F& scale, const PlaneF&  plane, PlaneF * result)
  G:\Torque3D\Engine\source\math\mOrientedBox.cpp (2 hits)
	Line 47: void OrientedBox3F::set( const MatrixF& transform, const Point3F& extents )
	Line 62: void OrientedBox3F::set( const MatrixF& transform, const Box3F& aabb )
  G:\Torque3D\Engine\source\math\mOrientedBox.h (5 hits)
	Line 35: class MatrixF;
	Line 71:       OrientedBox3F( const MatrixF& transform, const Point3F& extents ) { set( transform, extents ); }
	Line 72:       OrientedBox3F( const MatrixF& transform, const Box3F& aabb ) { set( transform, aabb ); }
	Line 103:       void set( const MatrixF& transform, const Point3F& extents );
	Line 109:       void set( const MatrixF& transform, const Box3F& aabb );
  G:\Torque3D\Engine\source\math\mPlaneTransformer.cpp (6 hits)
	Line 26: void PlaneTransformer::set(const MatrixF& xform, const Point3F& scale)
	Line 31:    MatrixF scaleMat(true);
	Line 33:    m[MatrixF::idx(0, 0)] = scale.x;
	Line 34:    m[MatrixF::idx(1, 1)] = scale.y;
	Line 35:    m[MatrixF::idx(2, 2)] = scale.z;
	Line 64:          MatrixF  defMat(true);
  G:\Torque3D\Engine\source\math\mPlaneTransformer.h (3 hits)
	Line 39:    MatrixF mTransform;
	Line 40:    MatrixF mTransposeInverse;
	Line 44:    void set(const MatrixF& xform, const Point3F& scale);
  G:\Torque3D\Engine\source\math\mPolyhedron.h (3 hits)
	Line 116:       static void buildBoxData( Polyhedron& poly, const MatrixF& mat, const Box3F& box, bool invertNormals = false );
	Line 169:       void buildBox( const MatrixF& mat, const Box3F& box, bool invertNormals = false )
	Line 323:       void transform( const MatrixF& matrix, const Point3F& scale = Point3F::One );
  G:\Torque3D\Engine\source\math\mPolyhedron.impl.h (2 hits)
	Line 51: void PolyhedronImpl< Base >::transform( const MatrixF& matrix, const Point3F& scale )
	Line 447: void PolyhedronData::buildBoxData( Polyhedron& poly, const MatrixF& mat, const Box3F& box, bool invertNormals )
  G:\Torque3D\Engine\source\math\mQuat.cpp (3 hits)
	Line 167: QuatF & QuatF::set( const MatrixF & mat )
	Line 206: MatrixF * QuatF::setMatrix( MatrixF * mat ) const
	Line 206: MatrixF * QuatF::setMatrix( MatrixF * mat ) const
  G:\Torque3D\Engine\source\math\mQuat.h (6 hits)
	Line 30: class MatrixF;
	Line 48:    QuatF( const MatrixF & m );
	Line 54:    QuatF& set( const MatrixF & m );
	Line 74:    MatrixF* setMatrix( MatrixF * mat ) const;
	Line 74:    MatrixF* setMatrix( MatrixF * mat ) const;
	Line 118: inline QuatF::QuatF( const MatrixF & m )
  G:\Torque3D\Engine\source\math\mRotation.cpp (6 hits)
	Line 103: //MatrixF setup
	Line 105: RotationF::RotationF(MatrixF _mat)
	Line 110: void RotationF::set(MatrixF _mat)
	Line 132:    MatrixF mat;
	Line 240: MatrixF RotationF::asMatrixF() const
	Line 242:    MatrixF returnMat;
  G:\Torque3D\Engine\source\math\mRotation.h (26 hits)
	Line 121:    RotationF(MatrixF mat);
	Line 122:    void set(MatrixF _mat);
	Line 124:    RotationF operator=(const MatrixF&);
	Line 125:    RotationF operator-(const MatrixF&) const;
	Line 126:    RotationF operator+(const MatrixF&) const;
	Line 127:    RotationF& operator-=(const MatrixF&);
	Line 128:    RotationF& operator+=(const MatrixF&);
	Line 129:    S32 operator==(const MatrixF&) const;
	Line 130:    S32 operator!=(const MatrixF&) const;
	Line 154:    MatrixF asMatrixF() const;
	Line 194:       MatrixF tempMat = asMatrixF();
	Line 195:       MatrixF tempMatAdd = _rotation.asMatrixF();
	Line 217:       MatrixF tempMat = asMatrixF();
	Line 218:       MatrixF tempMatAdd = _rotation.asMatrixF();
	Line 240:       MatrixF tempMat = asMatrixF();
	Line 241:       MatrixF tempMatAdd = _rotation.asMatrixF();
	Line 265:       MatrixF tempMat = asMatrixF();
	Line 266:       MatrixF tempMatAdd = _rotation.asMatrixF();
	Line 422: // MatrixF operators
	Line 424: inline RotationF RotationF::operator=(const MatrixF& _mat)
	Line 429: inline RotationF RotationF::operator-(const MatrixF& _mat) const
	Line 436: inline RotationF RotationF::operator+(const MatrixF& _mat) const
	Line 443: inline RotationF& RotationF::operator-=(const MatrixF& _mat)
	Line 449: inline RotationF& RotationF::operator+=(const MatrixF& _mat)
	Line 455: inline S32 RotationF::operator==(const MatrixF& _mat) const
	Line 460: inline S32 RotationF::operator!=(const MatrixF& _mat) const
  G:\Torque3D\Engine\source\math\mSilhouetteExtractor.h (2 hits)
	Line 89:       bool begin( const MatrixF& camView ) const
	Line 371:       U32 extractSilhouette( const MatrixF& camView, U32* outIndices, U32 maxOutIndices ) const
  G:\Torque3D\Engine\source\math\mSphere.cpp (1 hit)
	Line 31:    MatrixF worldToObj( true );
  G:\Torque3D\Engine\source\math\mTransform.h (4 hits)
	Line 61:       TransformF( const MatrixF& mat )
	Line 75:       void set( const MatrixF& mat )
	Line 87:       MatrixF getMatrix() const
	Line 89:          MatrixF mat;
  G:\Torque3D\Engine\source\math\test\mMatrixTest.cpp (1 hit)
	Line 42: TEST(MatrixF, MultiplyImplmentations)
  G:\Torque3D\Engine\source\math\test\mQuatTest.cpp (1 hit)
	Line 57:    MatrixF mat(eRot);
  G:\Torque3D\Engine\source\math\util\frustum.cpp (11 hits)
	Line 31: static const MatrixF sGFXProjRotMatrix( EulerF( (M_PI_F / 2.0f), 0.0f, 0.0f ) );
	Line 65:                   const MatrixF &transform )
	Line 93:                      const MatrixF &transform )
	Line 111:                      const MatrixF &transform )
	Line 130: void Frustum::set( const MatrixF &projMat, bool normalize )
	Line 217:    MatrixF xfm( mTransform ); 
	Line 491: void Frustum::setTransform( const MatrixF &mat )
	Line 517: void Frustum::mul( const MatrixF& mat )
	Line 525: void Frustum::mulL( const MatrixF& mat )
	Line 527:    MatrixF last( mTransform );
	Line 544: void Frustum::getProjectionMatrix( MatrixF *proj, bool gfxRotate ) const
  G:\Torque3D\Engine\source\math\util\frustum.h (15 hits)
	Line 171:       MatrixF mTransform;
	Line 261:       MatrixF mProjectionOffsetMatrix;
	Line 281:                const MatrixF &transform = MatrixF( true ) );
	Line 281:                const MatrixF &transform = MatrixF( true ) );
	Line 319:                   const MatrixF &mat = MatrixF( true ) );
	Line 319:                   const MatrixF &mat = MatrixF( true ) );
	Line 330:                   const MatrixF &transform = MatrixF( true ) );
	Line 330:                   const MatrixF &transform = MatrixF( true ) );
	Line 334:       //void set( const MatrixF& projMatrix, bool normalize );
	Line 395:       void setTransform( const MatrixF &transform );
	Line 398:       const MatrixF& getTransform() const { return mTransform; }
	Line 404:       void mul( const MatrixF &mat );
	Line 407:       void mulL( const MatrixF &mat );
	Line 430:       const MatrixF& getProjectionOffsetMatrix() const { return mProjectionOffsetMatrix; }
	Line 443:       void getProjectionMatrix( MatrixF *proj, bool gfxRotate=true ) const;
  G:\Torque3D\Engine\source\math\util\matrixSet.h (18 hits)
	Line 40:    typedef Delegate<const MatrixF &()> MatrixEvalDelegate;
	Line 57:    MatrixF mTransform[NumTransforms];
	Line 60:    const MatrixF *mViewSource;
	Line 61:    const MatrixF *mProjectionSource;
	Line 89:    inline const MatrixF &getObjectToWorld() const { return mTransform[ObjectToWorld]; }
	Line 90:    inline const MatrixF &getWorldToCamera() const { return mTransform[WorldToCamera]; }
	Line 91:    inline const MatrixF &getCameraToScreen() const { return mTransform[CameraToScreen]; }
	Line 94:    inline const MatrixF &getWorldToScreen() const { return mEvalDelegate[WorldToScreen](); }
	Line 95:    inline const MatrixF &getWorldViewProjection() const { return mEvalDelegate[ObjectToScreen](); }
	Line 96:    inline const MatrixF &getWorldToObject() const { return mEvalDelegate[WorldToObject](); }   
	Line 97:    inline const MatrixF &getCameraToWorld() const { return mEvalDelegate[CameraToWorld](); }
	Line 98:    inline const MatrixF &getObjectToCamera() const { return mEvalDelegate[ObjectToCamera](); }
	Line 99:    inline const MatrixF &getCameraToObject() const { return mEvalDelegate[CameraToObject](); }
	Line 102:    inline void setWorld(const MatrixF &world)
	Line 111:    inline void setView(const MatrixF &view)
	Line 125:    inline void setProjection(const MatrixF &projection)
	Line 136:    void setSceneView(const MatrixF &view)
	Line 144:    void setSceneProjection(const MatrixF &projection)
  G:\Torque3D\Engine\source\math\util\matrixSetDelegateMethods.h (3 hits)
	Line 27: #define MATRIX_SET_GET_VALUE(xfm) inline const MatrixF &MATRIX_SET_GET_VALUE_FN(xfm)() { return mTransform[xfm]; }
	Line 31: #define MATRIX_SET_IS_INVERSE_OF(inv_xfm, src_xfm) inline const MatrixF &MATRIX_SET_IS_INVERSE_OF_FN(inv_xfm, src_xfm)() \
	Line 40: #define MATRIX_SET_MULT_ASSIGN(matA, matB, matC) inline const MatrixF &MATRIX_SET_MULT_ASSIGN_FN(matA, matB, matC)() \
  G:\Torque3D\Engine\source\navigation\coverPoint.cpp (2 hits)
	Line 125: void CoverPoint::setTransform(const MatrixF & mat)
	Line 306:    MatrixF objectToWorld = getRenderTransform();
  G:\Torque3D\Engine\source\navigation\coverPoint.h (1 hit)
	Line 98:    void setTransform(const MatrixF &mat);
  G:\Torque3D\Engine\source\navigation\guiNavEditorCtrl.cpp (4 hits)
	Line 217:       MatrixF mat(true);
	Line 470:       const MatrixF &mat = mGizmo->getTransform();
	Line 525:    MatrixF mat;
	Line 539:          MatrixF mat(true);
  G:\Torque3D\Engine\source\navigation\navMesh.cpp (2 hits)
	Line 393: void NavMesh::setTransform(const MatrixF &mat)
	Line 1243:                MatrixF mat;
  G:\Torque3D\Engine\source\navigation\navMesh.h (2 hits)
	Line 215:    void setTransform(const MatrixF &mat);
	Line 383:       MatrixF trans;
  G:\Torque3D\Engine\source\navigation\navPath.cpp (2 hits)
	Line 344:       setTransform(MatrixF(true));
	Line 365:    MatrixF mat = Parent::getTransform();
  G:\Torque3D\Engine\source\platform\input\leapMotion\leapMotionData.h (2 hits)
	Line 74:    MatrixF mHandRot[LeapMotionConstants::MaxHands];
	Line 92:    MatrixF mPointableRot[LeapMotionConstants::MaxHands][LeapMotionConstants::MaxPointablesPerHand];
  G:\Torque3D\Engine\source\platform\input\leapMotion\leapMotionFrame.h (8 hits)
	Line 63:    Vector<MatrixF>   mHandRot;
	Line 76:    Vector<MatrixF>   mPointableRot;
	Line 111:    const MatrixF& getHandRot(U32 index) const;
	Line 124:    const MatrixF& getPointableRot(U32 index) const;
	Line 157: inline const MatrixF& LeapMotionFrame::getHandRot(U32 index) const
	Line 159:    return (index >= mHandCount) ? MatrixF::Identity : mHandRot[index];
	Line 207: inline const MatrixF& LeapMotionFrame::getPointableRot(U32 index) const
	Line 209:    return (index >= mPointableCount) ? MatrixF::Identity : mPointableRot[index];
  G:\Torque3D\Engine\source\platform\input\leapMotion\leapMotionUtil.cpp (3 hits)
	Line 50: void convertHandRotation(const Leap::Hand& hand, MatrixF& outRotation)
	Line 71: void calculateHandAxisRotation(const MatrixF& handRotation, const F32& maxHandAxisRadius, Point2F& outRotation)
	Line 90: void convertPointableRotation(const Leap::Pointable& pointable, MatrixF& outRotation)
  G:\Torque3D\Engine\source\platform\input\leapMotion\leapMotionUtil.h (3 hits)
	Line 39:    void convertHandRotation(const Leap::Hand& hand, MatrixF& outRotation);
	Line 42:    void calculateHandAxisRotation(const MatrixF& handRotation, const F32& maxHandAxisRadius, Point2F& outRotation);
	Line 45:    void convertPointableRotation(const Leap::Pointable& pointable, MatrixF& outRotation);
  G:\Torque3D\Engine\source\platform\input\oculusVR\oculusVRSensorData.h (1 hit)
	Line 55:    MatrixF mRot;
  G:\Torque3D\Engine\source\platform\input\oculusVR\oculusVRUtil.cpp (2 hits)
	Line 28: void convertRotation(const F32 inRotMat[4][4], MatrixF& outRotation)
	Line 53: void calculateAxisRotation(const MatrixF& inRotation, const F32& maxAxisRadius, Point2F& outRotation)
  G:\Torque3D\Engine\source\platform\input\oculusVR\oculusVRUtil.h (2 hits)
	Line 38:    void convertRotation(const F32 inRotMat[4][4], MatrixF& outRotation);
	Line 44:    void calculateAxisRotation(const MatrixF& inRotation, const F32& maxAxisRadius, Point2F& outRotation);
  G:\Torque3D\Engine\source\platform\input\razerHydra\razerHydraData.h (1 hit)
	Line 71:    MatrixF mRot;
  G:\Torque3D\Engine\source\platform\input\razerHydra\razerHydraFrame.h (4 hits)
	Line 45:       MatrixF mRot;
	Line 106:    const MatrixF& getRot(U32 index) const;
	Line 143: inline const MatrixF& RazerHydraFrame::getRot(U32 index) const
	Line 145:    return (index >= RazerHydraConstants::MaxControllers) ? MatrixF::Identity : mControllerData[index].mRot;
  G:\Torque3D\Engine\source\platform\input\razerHydra\razerHydraUtil.cpp (2 hits)
	Line 57: void convertRotation(const F32 inRotMat[3][3], MatrixF& outRotation)
	Line 72: void calculateAxisRotation(const MatrixF& inRotation, const F32& maxAxisRadius, Point2F& outRotation)
  G:\Torque3D\Engine\source\platform\input\razerHydra\razerHydraUtil.h (2 hits)
	Line 38:    void convertRotation(const F32 inRotMat[3][3], MatrixF& outRotation);
	Line 41:    void calculateAxisRotation(const MatrixF& inRotation, const F32& maxAxisRadius, Point2F& outRotation);
  G:\Torque3D\Engine\source\postFx\postEffect.cpp (11 hits)
	Line 505:       MatrixF camTrans = frustum.getTransform();
	Line 709:       MatrixF tempMat = thisFrame.cameraToScreen;
	Line 721:       MatrixF tempMat = thisFrame.cameraToScreen;
	Line 734:       MatrixF tempMat = lastFrame.cameraToScreen;
	Line 790:          MatrixF proj( true );
	Line 794:          MatrixF camMat = state->getCameraTransform();
	Line 796:          MatrixF tmp( true );
	Line 838:          const MatrixF &camMat = state->getCameraTransform();
	Line 848:          MatrixF mat = state->getCameraTransform();
	Line 964:    GFX->setWorldMatrix( MatrixF::Identity );
	Line 965:    GFX->setProjectionMatrix( MatrixF::Identity );
  G:\Torque3D\Engine\source\postFx\postEffectCommon.h (2 hits)
	Line 91:    MatrixF worldToCamera;
	Line 92:    MatrixF cameraToScreen;
  G:\Torque3D\Engine\source\postFx\postEffectManager.cpp (2 hits)
	Line 303: void PostEffectManager::setFrameMatrices( const MatrixF &worldToCamera, const MatrixF &cameraToScreen )
	Line 303: void PostEffectManager::setFrameMatrices( const MatrixF &worldToCamera, const MatrixF &cameraToScreen )
  G:\Torque3D\Engine\source\postFx\postEffectManager.h (2 hits)
	Line 130:    void setFrameMatrices( const MatrixF &worldToCamera, const MatrixF &cameraToScreen );
	Line 130:    void setFrameMatrices( const MatrixF &worldToCamera, const MatrixF &cameraToScreen );
  G:\Torque3D\Engine\source\renderInstance\renderImposterMgr.cpp (1 hit)
	Line 147:    matrixSet.setWorld( MatrixF::Identity );
  G:\Torque3D\Engine\source\renderInstance\renderOcclusionMgr.cpp (1 hit)
	Line 211:       MatrixF xfm( *ri->orientation );
  G:\Torque3D\Engine\source\renderInstance\renderParticleMgr.cpp (2 hits)
	Line 153:       screenClipper.setBaseTransform(MatrixF::Identity);
	Line 154:       screenClipper.setTransform(&MatrixF::Identity, Point3F::One);
  G:\Torque3D\Engine\source\renderInstance\renderParticleMgr.h (1 hit)
	Line 98:       MatrixF clipMatrix;
  G:\Torque3D\Engine\source\renderInstance\renderPassManager.cpp (3 hits)
	Line 243:    MatrixF proj = GFX->getProjectionMatrix();
	Line 314: const MatrixF* RenderPassManager::allocSharedXform( SharedTransformType stt )
	Line 327: void RenderPassManager::assignSharedXform( SharedTransformType stt, const MatrixF &xfm )
  G:\Torque3D\Engine\source\renderInstance\renderPassManager.h (12 hits)
	Line 141:    MatrixF* allocUniqueXform(const MatrixF& data) 
	Line 141:    MatrixF* allocUniqueXform(const MatrixF& data) 
	Line 143:       MatrixF *r = mChunker.alloc<MatrixF>(); 
	Line 143:       MatrixF *r = mChunker.alloc<MatrixF>(); 
	Line 154:    const MatrixF* allocSharedXform(SharedTransformType stt);
	Line 156:    void assignSharedXform(SharedTransformType stt, const MatrixF &xfm);
	Line 343:    const MatrixF *objectToWorld;       
	Line 346:    const MatrixF* worldToCamera;       
	Line 349:    const MatrixF* projection;         
	Line 401:    const MatrixF *modelViewProj;       
	Line 425:    const MatrixF *bbModelViewProj;
	Line 441:    const MatrixF *orientation;
  G:\Torque3D\Engine\source\renderInstance\renderPrePassMgr.cpp (5 hits)
	Line 345:    const MatrixF worldViewXfm = GFX->getWorldMatrix();
	Line 352:       matrixSet.setWorld(MatrixF::Identity);
	Line 1117:    GFX->setWorldMatrix( MatrixF::Identity );
	Line 1118:    GFX->setViewMatrix( MatrixF::Identity );
	Line 1119:    GFX->setProjectionMatrix( MatrixF::Identity );
  G:\Torque3D\Engine\source\renderInstance\renderTerrainMgr.cpp (2 hits)
	Line 140:    const MatrixF worldViewXfm = matrixSet.getWorldToCamera();
	Line 141:    const MatrixF &projXfm = matrixSet.getCameraToScreen();
  G:\Torque3D\Engine\source\renderInstance\renderTerrainMgr.h (1 hit)
	Line 52:    const MatrixF *objectToWorldXfm;
  G:\Torque3D\Engine\source\scene\culling\sceneCullingState.cpp (2 hits)
	Line 412:    const MatrixF& cameraTransform = getCameraState().getViewWorldMatrix();
	Line 823:       MatrixF terrWorldTransform = terrain->getWorldTransform();
  G:\Torque3D\Engine\source\scene\mixin\scenePolyhedralObject.impl.h (2 hits)
	Line 76:       mPolyhedron.buildBox( MatrixF::Identity, this->getObjBox() );
	Line 129:       MatrixF mat = this->getRenderTransform();
  G:\Torque3D\Engine\source\scene\reflector.cpp (21 hits)
	Line 400:    MatrixF matView(true);
	Line 609:       MatrixF inverseEyeTransforms[2];
	Line 689: void PlaneReflector::setGFXMatrices( const MatrixF &camTrans )
	Line 694:       MatrixF invObjTrans = mObject->getRenderTransform();
	Line 696:       MatrixF relCamTrans = invObjTrans * camTrans;
	Line 698:       MatrixF camReflectTrans = getCameraReflection( relCamTrans );
	Line 699:       MatrixF camTrans = mObject->getRenderTransform() * camReflectTrans;
	Line 709:       gClientSceneGraph->setNonClipProjection( (MatrixF&) GFX->getProjectionMatrix() );
	Line 710:       MatrixF clipProj = getFrustumClipProj( camTrans );
	Line 716:       MatrixF camReflectTrans = getCameraReflection( camTrans );
	Line 721:       gClientSceneGraph->setNonClipProjection( (MatrixF&) GFX->getProjectionMatrix() );
	Line 722:       MatrixF clipProj = getFrustumClipProj( camReflectTrans );
	Line 727: MatrixF PlaneReflector::getCameraReflection( const MatrixF &camTrans )
	Line 727: MatrixF PlaneReflector::getCameraReflection( const MatrixF &camTrans )
	Line 748:    MatrixF newTrans(true);
	Line 765: MatrixF PlaneReflector::getFrustumClipProj( MatrixF &modelview )
	Line 765: MatrixF PlaneReflector::getFrustumClipProj( MatrixF &modelview )
	Line 767:    static MatrixF rotMat(EulerF( static_cast<F32>(M_PI / 2.f), 0.0, 0.0));
	Line 768:    static MatrixF invRotMat(EulerF( -static_cast<F32>(M_PI / 2.f), 0.0, 0.0));
	Line 771:    MatrixF revModelview = modelview;
	Line 788:    MatrixF proj = GFX->getProjectionMatrix();
  G:\Torque3D\Engine\source\scene\reflector.h (5 hits)
	Line 206:    void setGFXMatrices( const MatrixF &camTrans );
	Line 209:    MatrixF getCameraReflection( const MatrixF &camTrans );
	Line 209:    MatrixF getCameraReflection( const MatrixF &camTrans );
	Line 212:    MatrixF getFrustumClipProj( MatrixF &modelview );
	Line 212:    MatrixF getFrustumClipProj( MatrixF &modelview );
  G:\Torque3D\Engine\source\scene\sceneCameraState.cpp (4 hits)
	Line 31: SceneCameraState::SceneCameraState( const RectI& viewport, const Frustum& frustum, const MatrixF& worldView, const MatrixF& projection )
	Line 31: SceneCameraState::SceneCameraState( const RectI& viewport, const Frustum& frustum, const MatrixF& worldView, const MatrixF& projection )
	Line 51:    const MatrixF& world = GFX->getWorldMatrix();
	Line 53:    MatrixF camera = world;
  G:\Torque3D\Engine\source\scene\sceneCameraState.h (7 hits)
	Line 52:       MatrixF mWorldViewMatrix;
	Line 55:       MatrixF mProjectionMatrix;
	Line 71:       SceneCameraState( const RectI& viewport, const Frustum& frustum, const MatrixF& worldView, const MatrixF& projection );
	Line 71:       SceneCameraState( const RectI& viewport, const Frustum& frustum, const MatrixF& worldView, const MatrixF& projection );
	Line 92:       const MatrixF& getViewWorldMatrix() const { return mFrustum.getTransform(); }
	Line 95:       const MatrixF& getWorldViewMatrix() const { return mWorldViewMatrix; }
	Line 98:       const MatrixF& getProjectionMatrix() const { return mProjectionMatrix; }
  G:\Torque3D\Engine\source\scene\sceneManager.cpp (6 hits)
	Line 100: SceneCameraState SceneManager::smLockedDiffuseCamera = SceneCameraState( RectI(), Frustum(), MatrixF(), MatrixF() );
	Line 100: SceneCameraState SceneManager::smLockedDiffuseCamera = SceneCameraState( RectI(), Frustum(), MatrixF(), MatrixF() );
	Line 239:       MatrixF originalWorld = GFX->getWorldMatrix();
	Line 244:       const MatrixF *eyeTransforms = GFX->getStereoEyeTransforms();
	Line 245:       const MatrixF *worldEyeTransforms = GFX->getInverseStereoEyeTransforms();
	Line 498:             MatrixF::Identity,
  G:\Torque3D\Engine\source\scene\sceneManager.h (3 hits)
	Line 134:       MatrixF mNonClipProj;
	Line 358:       void setNonClipProjection( const MatrixF &proj ) { mNonClipProj = proj; }
	Line 359:       const MatrixF& getNonClipProjection() const { return mNonClipProj; }
  G:\Torque3D\Engine\source\scene\sceneObject.cpp (16 hits)
	Line 138:    mMount.xfm = MatrixF::Identity;
	Line 384: void SceneObject::setTransform( const MatrixF& mat )
	Line 421:    setTransform(MatrixF(mObjToWorld));
	Line 483: void SceneObject::setRenderTransform(const MatrixF& mat)
	Line 597:       MatrixF txfm( so->getTransform() );
	Line 611:       MatrixF txfm( so->getTransform() );
	Line 836:          MatrixF xfm;
	Line 907:    MatrixF xform = mObjToWorld;
	Line 1063: void SceneObject::mountObject( SceneObject *obj, S32 node, const MatrixF &xfm )
	Line 1163: void SceneObject::getMountTransform( S32 index, const MatrixF &xfm, MatrixF *outMat )
	Line 1163: void SceneObject::getMountTransform( S32 index, const MatrixF &xfm, MatrixF *outMat )
	Line 1165:    MatrixF mountTransform( xfm );
	Line 1176: void SceneObject::getRenderMountTransform( F32 delta, S32 index, const MatrixF &xfm, MatrixF *outMat )
	Line 1176: void SceneObject::getRenderMountTransform( F32 delta, S32 index, const MatrixF &xfm, MatrixF *outMat )
	Line 1178:    MatrixF mountTransform( xfm );
	Line 1204:    ( SceneObject* objB, S32 slot, TransformF txfm ), ( MatrixF::Identity ),
  G:\Torque3D\Engine\source\scene\sceneObject.h (17 hits)
	Line 187:          MatrixF xfm;
	Line 273:       MatrixF mObjToWorld;
	Line 276:       MatrixF mWorldToObj;
	Line 291:       MatrixF mRenderObjToWorld;
	Line 294:       MatrixF mRenderWorldToObj;
	Line 472:       virtual const MatrixF& getTransform() const { return mObjToWorld; }
	Line 476:       const MatrixF& getWorldTransform() const { return mWorldToObj; }
	Line 496:       virtual void setTransform( const MatrixF &mat );
	Line 504:       virtual void setRenderTransform(const MatrixF &mat);
	Line 507:       const MatrixF& getRenderTransform() const { return mRenderObjToWorld; }
	Line 510:       const MatrixF& getRenderWorldTransform() const { return mRenderWorldToObj; }
	Line 619:       virtual void mountObject( SceneObject *obj, S32 node, const MatrixF &xfm = MatrixF::Identity );
	Line 619:       virtual void mountObject( SceneObject *obj, S32 node, const MatrixF &xfm = MatrixF::Identity );
	Line 640:       virtual void getMountTransform( S32 index, const MatrixF &xfm, MatrixF *outMat );
	Line 640:       virtual void getMountTransform( S32 index, const MatrixF &xfm, MatrixF *outMat );
	Line 644:       virtual void getRenderMountTransform( F32 delta, S32 index, const MatrixF &xfm, MatrixF *outMat );
	Line 644:       virtual void getRenderMountTransform( F32 delta, S32 index, const MatrixF &xfm, MatrixF *outMat );
  G:\Torque3D\Engine\source\scene\sceneRenderState.cpp (2 hits)
	Line 86: const MatrixF& SceneRenderState::getWorldViewMatrix() const
	Line 93: const MatrixF& SceneRenderState::getProjectionMatrix() const
  G:\Torque3D\Engine\source\scene\sceneRenderState.h (6 hits)
	Line 88:       MatrixF mDiffuseCameraTransform;
	Line 255:       const MatrixF& getWorldViewMatrix() const;
	Line 258:       const MatrixF& getProjectionMatrix() const;
	Line 265:       const MatrixF& getCameraTransform() const { return getCullingState().getCameraState().getViewWorldMatrix(); }
	Line 308:       const MatrixF& getDiffuseCameraTransform() const { return mDiffuseCameraTransform; }
	Line 312:       void setDiffuseCameraTransform( const MatrixF &mat ) { mDiffuseCameraTransform = mat; }
  G:\Torque3D\Engine\source\scene\sceneSpace.cpp (2 hits)
	Line 83: void SceneSpace::setTransform(const MatrixF & mat)
	Line 154:       MatrixF mat = getRenderTransform();
  G:\Torque3D\Engine\source\scene\sceneSpace.h (1 hit)
	Line 71:       virtual void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\scene\sgUtil.cpp (4 hits)
	Line 33: MatrixF sgWSToOSMatrix;
	Line 34: MatrixF sgProjMatrix;
	Line 268:                          const MatrixF&   modelview,
	Line 278:                               const MatrixF& worldSpaceToObjectSpace,
  G:\Torque3D\Engine\source\scene\sgUtil.h (3 hits)
	Line 35: class MatrixF;
	Line 50:                          const MatrixF&   modelview,
	Line 65:                               const MatrixF& worldSpaceToObjectSpace,
  G:\Torque3D\Engine\source\scene\simPath.cpp (2 hits)
	Line 492:    MatrixF mat = getRenderTransform();
	Line 521:    MatrixF otow;
  G:\Torque3D\Engine\source\scene\zones\scenePolyhedralZone.cpp (1 hit)
	Line 59: void ScenePolyhedralZone::setTransform( const MatrixF& mat )
  G:\Torque3D\Engine\source\scene\zones\scenePolyhedralZone.h (1 hit)
	Line 75:       virtual void setTransform( const MatrixF& mat );
  G:\Torque3D\Engine\source\scene\zones\sceneSimpleZone.cpp (1 hit)
	Line 238: void SceneSimpleZone::setTransform( const MatrixF& mat )
  G:\Torque3D\Engine\source\scene\zones\sceneSimpleZone.h (1 hit)
	Line 128:       virtual void setTransform( const MatrixF& mat );
  G:\Torque3D\Engine\source\sfx\dsound\sfxDSDevice.cpp (1 hit)
	Line 188:    const MatrixF& transform = listener.getTransform();
  G:\Torque3D\Engine\source\sfx\dsound\sfxDSVoice.cpp (1 hit)
	Line 164: void SFXDSVoice::setTransform( const MatrixF& transform )
  G:\Torque3D\Engine\source\sfx\dsound\sfxDSVoice.h (1 hit)
	Line 85:       void setTransform( const MatrixF& transform );
  G:\Torque3D\Engine\source\sfx\fmod\sfxFMODDevice.h (1 hit)
	Line 207: inline void TorqueTransformToFMODVectors( const MatrixF& transform, FMOD_VECTOR& position, FMOD_VECTOR& forward, FMOD_VECTOR& up )
  G:\Torque3D\Engine\source\sfx\fmod\sfxFMODEventSource.cpp (2 hits)
	Line 196: void SFXFMODEventSource::setTransform( const MatrixF& transform )
	Line 249: void SFXFMODEventSource::_updateVolume( const MatrixF& listener )
  G:\Torque3D\Engine\source\sfx\fmod\sfxFMODEventSource.h (2 hits)
	Line 68:       virtual void _updateVolume( const MatrixF& listener );
	Line 93:       virtual void setTransform( const MatrixF& transform );
  G:\Torque3D\Engine\source\sfx\fmod\sfxFMODVoice.cpp (1 hit)
	Line 206: void SFXFMODVoice::setTransform( const MatrixF& transform )
  G:\Torque3D\Engine\source\sfx\fmod\sfxFMODVoice.h (1 hit)
	Line 112:       void setTransform( const MatrixF& transform );
  G:\Torque3D\Engine\source\sfx\null\sfxNullVoice.cpp (1 hit)
	Line 107: void SFXNullVoice::setTransform( const MatrixF& transform )
  G:\Torque3D\Engine\source\sfx\null\sfxNullVoice.h (1 hit)
	Line 80:       void setTransform( const MatrixF& transform );
  G:\Torque3D\Engine\source\sfx\openal\sfxALDevice.cpp (1 hit)
	Line 136:    const MatrixF &transform = listener.getTransform();
  G:\Torque3D\Engine\source\sfx\openal\sfxALVoice.cpp (1 hit)
	Line 216: void SFXALVoice::setTransform( const MatrixF& transform )
  G:\Torque3D\Engine\source\sfx\openal\sfxALVoice.h (1 hit)
	Line 100:       void setTransform( const MatrixF& transform );
  G:\Torque3D\Engine\source\sfx\sfxCommon.h (4 hits)
	Line 501:       MatrixF mTransform;
	Line 510:       SFXListenerProperties( const MatrixF& transform, const Point3F& velocity )
	Line 515:       const MatrixF& getTransform() const { return mTransform; }
	Line 516:       MatrixF& getTransform() { return mTransform; }
  G:\Torque3D\Engine\source\sfx\sfxController.cpp (1 hit)
	Line 744: void SFXController::_updateVolume( const MatrixF& listener )
  G:\Torque3D\Engine\source\sfx\sfxController.h (1 hit)
	Line 191:       virtual void _updateVolume( const MatrixF& listener );
  G:\Torque3D\Engine\source\sfx\sfxSound.cpp (2 hits)
	Line 475: void SFXSound::_updateVolume( const MatrixF& listener )
	Line 543: void SFXSound::setTransform( const MatrixF& transform )
  G:\Torque3D\Engine\source\sfx\sfxSound.h (2 hits)
	Line 109:       virtual void _updateVolume( const MatrixF& listener );
	Line 155:       virtual void setTransform( const MatrixF& transform );
  G:\Torque3D\Engine\source\sfx\sfxSource.cpp (8 hits)
	Line 792: void SFXSource::_updateVolume( const MatrixF& listener )
	Line 938: void SFXSource::setTransform( const MatrixF& transform )
	Line 1264:                MatrixF transform( angles );
	Line 1274:                MatrixF transform( angles );
	Line 1284:                MatrixF transform( angles );
	Line 1540:    MatrixF mat = source->getTransform();
	Line 1549:    MatrixF mat = source->getTransform();
	Line 1577:    MatrixF mat = object->getTransform();
  G:\Torque3D\Engine\source\sfx\sfxSource.h (4 hits)
	Line 176:       virtual void _updateVolume( const MatrixF& listener );
	Line 226:       MatrixF mTransform;
	Line 491:       const MatrixF& getTransform() const { return mTransform; }
	Line 494:       virtual void setTransform( const MatrixF& transform );
  G:\Torque3D\Engine\source\sfx\sfxSystem.cpp (8 hits)
	Line 533:                                     const MatrixF* transform, 
	Line 741:                                  const MatrixF *transform,
	Line 1102: void SFXSystem::setListener( U32 index, const MatrixF& transform, const Point3F& velocity )
	Line 1476:          MatrixF transform;
	Line 1498:             MatrixF transform;
	Line 1580:    MatrixF transform;
	Line 1688:          MatrixF transform;
	Line 1708:             MatrixF transform;
  G:\Torque3D\Engine\source\sfx\sfxSystem.h (4 hits)
	Line 309:                                 const MatrixF* transform = NULL, 
	Line 346:                            const MatrixF* transform = NULL,
	Line 350:                            const MatrixF* transform = NULL,
	Line 385:       void setListener( U32 index, const MatrixF& transform, const Point3F& velocity );
  G:\Torque3D\Engine\source\sfx\sfxVoice.h (1 hit)
	Line 187:       virtual void setTransform( const MatrixF &transform ) = 0;
  G:\Torque3D\Engine\source\sfx\xaudio\sfxXAudioDevice.cpp (1 hit)
	Line 213:    const MatrixF& transform = listener.getTransform();
  G:\Torque3D\Engine\source\sfx\xaudio\sfxXAudioVoice.cpp (1 hit)
	Line 392: void SFXXAudioVoice::setTransform( const MatrixF& transform )
  G:\Torque3D\Engine\source\sfx\xaudio\sfxXAudioVoice.h (1 hit)
	Line 142:       void setTransform( const MatrixF& transform );
  G:\Torque3D\Engine\source\T3D\accumulationVolume.cpp (2 hits)
	Line 157: void AccumulationVolume::setTransform( const MatrixF& mat )
	Line 190:       MatrixF camView( true );
  G:\Torque3D\Engine\source\T3D\accumulationVolume.h (1 hit)
	Line 101:       virtual void setTransform( const MatrixF& mat );
  G:\Torque3D\Engine\source\T3D\aiClient.cpp (3 hits)
	Line 219:    MatrixF moveMatrix;
	Line 243:       MatrixF const& myTransform = mPlayer->getTransform();
	Line 568:    MatrixF const &myTransform = player->getTransform();
  G:\Torque3D\Engine\source\T3D\aiPlayer.cpp (6 hits)
	Line 183:    MatrixF eye;
	Line 301:    MatrixF mat;
	Line 377:    MatrixF eye;
	Line 522:          MatrixF moveMatrix;
	Line 1305:       MatrixF eyeMat;
	Line 1350:    MatrixF cam = getTransform();
  G:\Torque3D\Engine\source\T3D\camera.cpp (25 hits)
	Line 369: void Camera::getCameraTransform(F32* pos, MatrixF* mat)
	Line 383: void Camera::getEyeCameraTransform(IDisplayDevice *displayDevice, U32 eyeId, MatrixF *outMat)
	Line 630:                MatrixF ret;
	Line 703:                MatrixF ret;
	Line 878:             MatrixF ret;
	Line 907:          MatrixF ret;
	Line 937:    MatrixF xRot, zRot;
	Line 941:    MatrixF temp;
	Line 946:       MatrixF imat;
	Line 948:       MatrixF ymat;
	Line 966:    MatrixF xRot, zRot;
	Line 970:    MatrixF temp;
	Line 975:       MatrixF imat;
	Line 977:       MatrixF ymat;
	Line 995:    MatrixF xRot, zRot;
	Line 999:    MatrixF temp;
	Line 1006:       MatrixF imat;
	Line 1008:       MatrixF ymat;
	Line 1552: void Camera::_validateEyePoint(F32 pos, MatrixF *mat)
	Line 1605: void Camera::setTransform(const MatrixF& mat)
	Line 1620: void Camera::setRenderTransform(const MatrixF& mat)
	Line 1712: void Camera::_calcOrbitPoint( MatrixF* mat, const Point3F& rot )
	Line 1725: void Camera::_calcEditOrbitPoint( MatrixF *mat, const Point3F& rot )
	Line 1913:    MatrixF mat;
	Line 1961:    MatrixF mat;
  G:\Torque3D\Engine\source\T3D\camera.h (7 hits)
	Line 150:       void _validateEyePoint( F32 pos, MatrixF* mat );
	Line 152:       void _calcOrbitPoint( MatrixF* mat, const Point3F& rot );
	Line 153:       void _calcEditOrbitPoint( MatrixF *mat, const Point3F& rot );
	Line 165:       virtual void setTransform( const MatrixF& mat );
	Line 166:       virtual void setRenderTransform( const MatrixF& mat );
	Line 238:       virtual void getCameraTransform( F32* pos,MatrixF* mat );
	Line 239:       virtual void getEyeCameraTransform( IDisplayDevice *display, U32 eyeId, MatrixF *outMat );
  G:\Torque3D\Engine\source\T3D\components\camera\cameraComponent.cpp (11 hits)
	Line 226:    MatrixF camTransform = mOwner->getTransform();
	Line 235: bool CameraComponent::getCameraTransform(F32* pos,MatrixF* mat)
	Line 245:          MatrixF rMat = mOwner->getRenderTransform();
	Line 267:          MatrixF rMat = mOwner->getRenderTransform();
	Line 276:             MatrixF nodeTrans = renderInterface->getNodeTransform(mTargetNodeIdx);
	Line 292:          MatrixF rotMat = rot.asMatrixF();
	Line 294:          MatrixF rotOffsetMat = mRotOffset.asMatrixF();
	Line 304:          MatrixF rMat = mOwner->getRenderTransform();
	Line 313:             MatrixF nodeTrans = renderInterface->getNodeTransform(mTargetNodeIdx);
	Line 332: void CameraComponent::getCameraParameters(F32 *min, F32* max, Point3F* off, MatrixF* rot)
	Line 400:    MatrixF mat;
  G:\Torque3D\Engine\source\T3D\components\camera\cameraComponent.h (2 hits)
	Line 117:    virtual void getCameraParameters(F32 *min, F32* max, Point3F* offset, MatrixF* rot);
	Line 123:    virtual bool getCameraTransform(F32* pos, MatrixF* mat);
  G:\Torque3D\Engine\source\T3D\components\camera\cameraComponent_ScriptBinding.h (4 hits)
	Line 38:    MatrixF cameraMat;
	Line 52:    MatrixF cameraMat;
	Line 66:    MatrixF cameraMat;
	Line 87:    MatrixF mat;
  G:\Torque3D\Engine\source\T3D\components\camera\cameraOrbiterComponent.cpp (2 hits)
	Line 144:       MatrixF ownerTrans = mOwner->getRenderTransform();
	Line 156:       MatrixF xRot, zRot, cameraMatrix;
  G:\Torque3D\Engine\source\T3D\components\collision\collisionComponent.cpp (8 hits)
	Line 319: void CollisionComponent::ownerTransformSet(MatrixF *mat)
	Line 348:       MatrixF offset(true);
	Line 419:       MatrixF offset(true);
	Line 478:       polyList.setTransform(&MatrixF::Identity, mOwner->getScale());
	Line 503:          MatrixF localXfm;
	Line 552:             MatrixF localXfm;
	Line 566:             MatrixF meshMat(localXfm);
	Line 572:             polyList.setTransform(&MatrixF::Identity, mOwner->getScale());
  G:\Torque3D\Engine\source\T3D\components\collision\collisionComponent.h (1 hit)
	Line 118:    virtual void ownerTransformSet(MatrixF *mat);
  G:\Torque3D\Engine\source\T3D\components\collision\collisionTrigger.cpp (8 hits)
	Line 291: void CollisionTrigger::setTransform(const MatrixF & mat)
	Line 299:       MatrixF base(true);
	Line 341:    MatrixF mat = getRenderTransform();
	Line 373:    MatrixF xform = getTransform();
	Line 381:    MatrixF base(true);
	Line 395:       MatrixF colMat(true);
	Line 399:       //MatrixF colMat( true );
	Line 548:       MatrixF temp;
  G:\Torque3D\Engine\source\T3D\components\collision\collisionTrigger.h (1 hit)
	Line 113:    void setTransform(const MatrixF &mat);
  G:\Torque3D\Engine\source\T3D\components\component.cpp (1 hit)
	Line 236: void Component::ownerTransformSet(MatrixF *mat)
  G:\Torque3D\Engine\source\T3D\components\component.h (1 hit)
	Line 105:    virtual void ownerTransformSet(MatrixF *mat);
  G:\Torque3D\Engine\source\T3D\components\coreInterfaces.h (2 hits)
	Line 58:    virtual void setTransform( MatrixF transform );
	Line 79:    virtual bool getCameraTransform(F32* pos,MatrixF* mat)=0;
  G:\Torque3D\Engine\source\T3D\components\game\triggerComponent.cpp (1 hit)
	Line 237:                MatrixF ownerTransform = mOwner->getTransform();
  G:\Torque3D\Engine\source\T3D\components\physics\physicsBehavior.cpp (7 hits)
	Line 213:    colShape->addBox( mObjBox.getExtents() * 0.5f, MatrixF::Identity );
	Line 250: void PhysicsComponent::setTransform(const MatrixF& mat)
	Line 268:    MatrixF mat = mOwner->getTransform();
	Line 287:    MatrixF mat = mOwner->getRenderTransform();
	Line 328:    MatrixF iv,qmat;
	Line 329:    MatrixF inverse = MatrixF::Identity;
	Line 329:    MatrixF inverse = MatrixF::Identity;
  G:\Torque3D\Engine\source\T3D\components\physics\physicsBehavior.h (1 hit)
	Line 120:    virtual void setTransform(const MatrixF& mat);
  G:\Torque3D\Engine\source\T3D\components\physics\playerControllerComponent.cpp (7 hits)
	Line 253:       MatrixF trans;
	Line 290: void PlayerControllerComponent::ownerTransformSet(MatrixF *mat)
	Line 296: void PlayerControllerComponent::setTransform(const MatrixF& mat)
	Line 420:    MatrixF zRot;
	Line 528:       MatrixF xRot, zRot;
	Line 531:       MatrixF rot;
	Line 723:    MatrixF newMat;
  G:\Torque3D\Engine\source\T3D\components\physics\playerControllerComponent.h (2 hits)
	Line 179:    virtual void ownerTransformSet(MatrixF *mat);
	Line 193:    virtual void setTransform(const MatrixF& mat);
  G:\Torque3D\Engine\source\T3D\components\physics\rigidBodyComponent.cpp (2 hits)
	Line 58:    mResetPos = MatrixF::Identity;
	Line 148: void RigidBodyComponent::ownerTransformSet(MatrixF *mat)
  G:\Torque3D\Engine\source\T3D\components\physics\rigidBodyComponent.h (2 hits)
	Line 83:    MatrixF mResetPos;
	Line 157:    virtual void ownerTransformSet(MatrixF *mat);
  G:\Torque3D\Engine\source\T3D\components\render\meshComponent.cpp (6 hits)
	Line 88:          MatrixF mat = mOwner->getNodeTransform(nodeID);
	Line 303:    MatrixF mat = mOwner->getRenderTransform();
	Line 422: MatrixF MeshComponent::getNodeTransform(S32 nodeIdx)
	Line 431:          MatrixF mountTransform = mShapeInstance->mNodeTransforms[nodeIdx];
	Line 438:    return MatrixF::Identity;
	Line 458: void MeshComponent::mountObjectToNode(SceneObject* objB, String node, MatrixF txfm)
  G:\Torque3D\Engine\source\T3D\components\render\meshComponent.h (5 hits)
	Line 137:    virtual MatrixF getNodeTransform(S32 nodeIdx);
	Line 162:    void mountObjectToNode(SceneObject* objB, String node, MatrixF txfm);
	Line 171:    virtual Vector<MatrixF> getNodeTransforms()
	Line 173:       Vector<MatrixF> bob;
	Line 177:    virtual void setNodeTransforms(Vector<MatrixF> transforms)
  G:\Torque3D\Engine\source\T3D\components\render\meshComponent_ScriptBinding.h (14 hits)
	Line 42:    (SceneObject* objB, String node, TransformF txfm), (MatrixF::Identity),
	Line 53:       //for the SceneObject mountobject method. Hackish, but for now, just default to a clean MatrixF::Identity
	Line 54:       object->mountObjectToNode(objB, node, /*MatrixF::Identity*/txfm.getMatrix());
	Line 72:       //for the SceneObject mountobject method. Hackish, but for now, just default to a clean MatrixF::Identity
	Line 73:       //object->mountObjectToNode( objB, node, /*MatrixF::Identity*/txfm.getMatrix() );
	Line 74:       MatrixF mat = object->getNodeTransform(node);
	Line 93:       //for the SceneObject mountobject method. Hackish, but for now, just default to a clean MatrixF::Identity
	Line 94:       //object->mountObjectToNode( objB, node, /*MatrixF::Identity*/txfm.getMatrix() );
	Line 95:       MatrixF mat = object->getNodeTransform(node);
	Line 119:       //for the SceneObject mountobject method. Hackish, but for now, just default to a clean MatrixF::Identity
	Line 120:       //object->mountObjectToNode( objB, node, /*MatrixF::Identity*/txfm.getMatrix() );
	Line 121:       MatrixF mat = object->getNodeTransform(node);
	Line 141:       //for the SceneObject mountobject method. Hackish, but for now, just default to a clean MatrixF::Identity
	Line 142:       //object->mountObjectToNode( objB, node, /*MatrixF::Identity*/txfm.getMatrix() );
  G:\Torque3D\Engine\source\T3D\components\render\renderComponentInterface.h (3 hits)
	Line 47:    virtual MatrixF getNodeTransform(S32 nodeIdx) = 0;
	Line 49:    virtual Vector<MatrixF> getNodeTransforms() = 0;
	Line 51:    virtual void setNodeTransforms(Vector<MatrixF> transforms) = 0;
  G:\Torque3D\Engine\source\T3D\convexShape.cpp (28 hits)
	Line 89: void ConvexShapeCollisionConvex::getFeatures( const MatrixF &mat, const VectorF &n, ConvexFeature *cf )
	Line 207: 	//MatrixF mat;
	Line 219: 	MatrixF surface;
	Line 330:          MatrixF &surf = mSurfaces.last();
	Line 379:       const MatrixF &mat = mSurfaces[i];
	Line 410: void ConvexShape::setTransform( const MatrixF &mat )
	Line 476:          MatrixF &mat = mSurfaces.last();
	Line 534:    MatrixF objectToWorld = getRenderTransform();
	Line 706:    MatrixF saveMat;
	Line 870:    MatrixF objToWorld( mObjToWorld );
	Line 879: MatrixF ConvexShape::getSurfaceWorldMat( S32 surfId, bool scaled ) const
	Line 882:       return MatrixF::Identity;      
	Line 884:    MatrixF objToWorld( mObjToWorld );
	Line 889:    MatrixF surfMat;
	Line 959:       MatrixF objToPlane( mSurfaces[i] );
	Line 1151:    MatrixF xfm( getWorldTransform() );
	Line 1164:                                  MatrixF::Identity ) )
	Line 1206:       MatrixF xfm( getRenderTransform() );
	Line 1251:    MatrixF objToWorld( mObjToWorld );
	Line 1322:       MatrixF xfm( getRenderTransform() );
	Line 1342:          MatrixF objToWorld( mObjToWorld );
	Line 1345:          MatrixF renderMat;
	Line 1363:    MatrixF xfm( mObjToWorld );
	Line 1371:    MatrixF projBias(true);
	Line 1424:    const MatrixF &surfToObj = mSurfaces[ faceId ];
	Line 1425:    MatrixF objToSurf( surfToObj );
	Line 1449:       MatrixF objToWorld( mObjToWorld );
	Line 1626:       MatrixF quadMat( true );
  G:\Torque3D\Engine\source\T3D\convexShape.h (5 hits)
	Line 62: 	void getFeatures(const MatrixF& mat,const VectorF& n, ConvexFeature* cf);
	Line 171:    virtual void setTransform( const MatrixF &mat );   
	Line 185:       MatrixF getSurfaceWorldMat( S32 faceid, bool scaled = false ) const;
	Line 191:       Vector<MatrixF>& getSurfaces() { return mSurfaces; }
	Line 235:    Vector< MatrixF > mSurfaces;
  G:\Torque3D\Engine\source\T3D\debris.cpp (7 hits)
	Line 705:                MatrixF stat = getTransform();
	Line 711:                MatrixF newTrans = MathUtils::createOrientFromDir( dir );
	Line 737:    MatrixF curTrans = getTransform();
	Line 741:    MatrixF rotMatrix( EulerF( curAngles.x, curAngles.y, curAngles.z ) );
	Line 806:    MatrixF trans( true );
	Line 923:       MatrixF mat = getRenderTransform();
	Line 933:          MatrixF mat = getRenderTransform();
  G:\Torque3D\Engine\source\T3D\debris.h (1 hit)
	Line 119:    MatrixF           mInitialTrans;
  G:\Torque3D\Engine\source\T3D\decal\decalInstance.cpp (1 hit)
	Line 27: void DecalInstance::getWorldMatrix( MatrixF *outMat, bool flip )
  G:\Torque3D\Engine\source\T3D\decal\decalInstance.h (1 hit)
	Line 75:       void getWorldMatrix( MatrixF *outMat, bool flip = false );
  G:\Torque3D\Engine\source\T3D\decal\decalManager.cpp (8 hits)
	Line 323:    MatrixF projMat( true );
	Line 508:    MatrixF mat( true );
	Line 512:    MatrixF rotmat;
	Line 1206:    MatrixF *tempMat = renderPass->allocUniqueXform( MatrixF( true ) );
	Line 1206:    MatrixF *tempMat = renderPass->allocUniqueXform( MatrixF( true ) );
	Line 1210:    baseRenderInst.objectToWorld = &MatrixF::Identity;
	Line 1764:    MatrixF mat( true );
	Line 1768:    MatrixF rotmat;
  G:\Torque3D\Engine\source\T3D\entity.cpp (35 hits)
	Line 190:       //MatrixF mat = rot.asMatrixF();
	Line 295:             MatrixF mat;
	Line 499:       //MatrixF objToWorld;
	Line 675: void Entity::setTransform(const MatrixF &mat)
	Line 713:       MatrixF transf = addRot.asMatrixF();
	Line 753:       MatrixF transf = addRot.asMatrixF();
	Line 762:       /*MatrixF newMat, imat, xmat, ymat, zmat;
	Line 770:       MatrixF newMat = rotation.asMatrixF();
	Line 807: void Entity::setRenderTransform(const MatrixF &mat)
	Line 820:       MatrixF transf = addRot.asMatrixF();
	Line 827:       MatrixF newMat = rotation.asMatrixF();
	Line 840: MatrixF Entity::getTransform()
	Line 844:       MatrixF mat;
	Line 877:       MatrixF temp, imat, xmat, ymat, zmat;
	Line 895: void Entity::getCameraTransform(F32* pos, MatrixF* mat)
	Line 907: void Entity::getMountTransform(S32 index, const MatrixF &xfm, MatrixF *outMat)
	Line 907: void Entity::getMountTransform(S32 index, const MatrixF &xfm, MatrixF *outMat)
	Line 918:          MatrixF mountTransform = renderInterface->getShapeInstance()->mNodeTransforms[index];
	Line 937: void Entity::getRenderMountTransform(F32 delta, S32 index, const MatrixF &xfm, MatrixF *outMat)
	Line 937: void Entity::getRenderMountTransform(F32 delta, S32 index, const MatrixF &xfm, MatrixF *outMat)
	Line 948:          MatrixF mountTransform = renderInterface->getShapeInstance()->mNodeTransforms[index];
	Line 969:    MatrixF mat = getTransform();
	Line 1074: void Entity::mountObject(SceneObject* objB, MatrixF txfm)
	Line 1080: void Entity::mountObject(SceneObject *obj, S32 node, const MatrixF &xfm)
	Line 1133:       MatrixF offset;
	Line 1147:             mountObject(e, nodeIdx, MatrixF::Identity);
	Line 1151:             mountObject(e, MatrixF::Identity);
	Line 1162:          mountObject(e, MatrixF::Identity);*/
	Line 1164:          mountObject(e, MatrixF::Identity);
	Line 1184:          MatrixF offset = rotOffset.asMatrixF();
	Line 1686:    (SceneObject* objB, TransformF txfm), (MatrixF::Identity),
	Line 1697:       //for the SceneObject mountobject method. Hackish, but for now, just default to a clean MatrixF::Identity
	Line 1698:       object->mountObject(objB, /*MatrixF::Identity*/txfm.getMatrix());
	Line 1736:    MatrixF mat;
	Line 1737:    object->getMountTransform(0, MatrixF::Identity, &mat);
  G:\Torque3D\Engine\source\T3D\entity.h (14 hits)
	Line 66:    Signal< void(MatrixF*) > onTransformSet;
	Line 116:    virtual void setTransform(const MatrixF &mat);
	Line 117:    virtual void setRenderTransform(const MatrixF &mat);
	Line 123:    virtual MatrixF getTransform();
	Line 146:    virtual void getMountTransform(S32 index, const MatrixF &xfm, MatrixF *outMat);
	Line 146:    virtual void getMountTransform(S32 index, const MatrixF &xfm, MatrixF *outMat);
	Line 147:    virtual void getRenderMountTransform(F32 delta, S32 index, const MatrixF &xfm, MatrixF *outMat);
	Line 147:    virtual void getRenderMountTransform(F32 delta, S32 index, const MatrixF &xfm, MatrixF *outMat);
	Line 151:    virtual void mountObject(SceneObject *obj, S32 node, const MatrixF &xfm = MatrixF::Identity);
	Line 151:    virtual void mountObject(SceneObject *obj, S32 node, const MatrixF &xfm = MatrixF::Identity);
	Line 152:    void mountObject(SceneObject* objB, MatrixF txfm);
	Line 201:    virtual void getCameraTransform(F32* pos, MatrixF* mat);
	Line 240:    MatrixF getWorldToObj() { return mWorldToObj; }
	Line 241:    MatrixF getObjToWorld() { return mObjToWorld; }
  G:\Torque3D\Engine\source\T3D\examples\renderMeshExample.cpp (2 hits)
	Line 125: void RenderMeshExample::setTransform(const MatrixF & mat)
	Line 308:    MatrixF objectToWorld = getRenderTransform();
  G:\Torque3D\Engine\source\T3D\examples\renderMeshExample.h (1 hit)
	Line 107:    void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\T3D\examples\renderObjectExample.cpp (2 hits)
	Line 100: void RenderObjectExample::setTransform(const MatrixF & mat)
	Line 257:    MatrixF objectToWorld = getRenderTransform();
  G:\Torque3D\Engine\source\T3D\examples\renderObjectExample.h (1 hit)
	Line 104:    void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\T3D\examples\renderShapeExample.cpp (2 hits)
	Line 124: void RenderShapeExample::setTransform(const MatrixF & mat)
	Line 264:    MatrixF mat = getRenderTransform();
  G:\Torque3D\Engine\source\T3D\examples\renderShapeExample.h (1 hit)
	Line 95:    void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\T3D\fps\guiCrossHairHud.cpp (1 hit)
	Line 128:    MatrixF cam;
  G:\Torque3D\Engine\source\T3D\fps\guiShapeNameHud.cpp (3 hits)
	Line 181:    MatrixF cam;
	Line 216:                MatrixF eye;
	Line 226:                MatrixF srtMat = shape->getRenderTransform();
  G:\Torque3D\Engine\source\T3D\fx\cameraFXMgr.cpp (2 hits)
	Line 99:    MatrixF rotMatrix( EulerF( rotAngles.x, rotAngles.y, rotAngles.z ) );
	Line 198:       MatrixF fxTrans = curFX->getTrans();
  G:\Torque3D\Engine\source\T3D\fx\cameraFXMgr.h (4 hits)
	Line 42:    MatrixF  mCamFXTrans;
	Line 50:    MatrixF &   getTrans(){ return mCamFXTrans; }
	Line 96:    MatrixF              mCamFXTrans;
	Line 104:    MatrixF &   getTrans(){ return mCamFXTrans; }
  G:\Torque3D\Engine\source\T3D\fx\explosion.cpp (6 hits)
	Line 861:       MatrixF axisOrient = MathUtils::createOrientFromDir( mInitialNormal );
	Line 863:       MatrixF trans = getTransform();
	Line 1020:    MatrixF rotMatrix( true );
	Line 1036:    MatrixF explOrient = MathUtils::createOrientFromDir( targetVector );
	Line 1053:    MatrixF proj = GFX->getProjectionMatrix();
	Line 1219:          MatrixF trans = getTransform();
  G:\Torque3D\Engine\source\T3D\fx\fxFoliageReplicator.cpp (5 hits)
	Line 226: bool fxFoliageRenderList::IsQuadrantVisible(const Box3F VisBox, const MatrixF& RenderTransform)
	Line 1550:             MatrixF proj = GFX->getProjectionMatrix();
	Line 1555:             MatrixF world = GFX->getWorldMatrix();
	Line 1616: void fxFoliageReplicator::renderQuad(fxFoliageQuadrantNode* quadNode, const MatrixF& RenderTransform, const bool UseDebug)
	Line 1725:       MatrixF		ReplicatorObjectMatrix;
  G:\Torque3D\Engine\source\T3D\fx\fxFoliageReplicator.h (3 hits)
	Line 67:    MatrixF     Transform;		
	Line 127:    bool IsQuadrantVisible(const Box3F VisBox, const MatrixF& RenderTransform);
	Line 233: 	void renderQuad(fxFoliageQuadrantNode* quadNode, const MatrixF& RenderTransform, const bool UseDebug);
  G:\Torque3D\Engine\source\T3D\fx\fxShapeReplicator.cpp (2 hits)
	Line 376:       MatrixF XForm = fxStatic->getTransform();
	Line 723:       MatrixF		ReplicatorObjectMatrix;
  G:\Torque3D\Engine\source\T3D\fx\fxShapeReplicator.h (1 hit)
	Line 59:    void setTransform(const MatrixF & mat) { Parent::setTransform(mat); setRenderTransform(mat); };
  G:\Torque3D\Engine\source\T3D\fx\groundCover.cpp (3 hits)
	Line 294:    MatrixF worldMat;
	Line 391:       ri->objectToWorld = &MatrixF::Identity;
	Line 1579:       const MatrixF &camMat = state->getDiffuseCameraTransform();
  G:\Torque3D\Engine\source\T3D\fx\lightning.cpp (2 hits)
	Line 532:       MatrixF cameraMatrix;
	Line 698:       MatrixF trans(true);
  G:\Torque3D\Engine\source\T3D\fx\particleEmitter.cpp (5 hits)
	Line 1242:    MatrixF temp = getTransform();
	Line 1293:    MatrixF temp(true);
	Line 1491:      MatrixF modelview = GFX->getWorldMatrix();
	Line 1616:       MatrixF camView = GFX->getWorldMatrix();
	Line 1681:                                       const MatrixF &camView,
  G:\Torque3D\Engine\source\T3D\fx\particleEmitter.h (2 hits)
	Line 206:                                const MatrixF &camView,
	Line 256:    MatrixF   mBBObjToWorld;
  G:\Torque3D\Engine\source\T3D\fx\particleEmitterNode.cpp (2 hits)
	Line 274:       MatrixF mat;
	Line 338:       MatrixF temp;
  G:\Torque3D\Engine\source\T3D\fx\precipitation.cpp (7 hits)
	Line 326: void Precipitation::setTransform(const MatrixF & mat)
	Line 718:       MatrixF mat;
	Line 1353:    MatrixF camMat;
	Line 1534:    MatrixF world = GFX->getWorldMatrix();
	Line 1535:    MatrixF proj = GFX->getProjectionMatrix();
	Line 1567:       MatrixF camMat = state->getCameraTransform();
	Line 1776:    MatrixF camMat = state->getCameraTransform();
  G:\Torque3D\Engine\source\T3D\fx\precipitation.h (1 hit)
	Line 251:    void setTransform(const MatrixF &mat);
  G:\Torque3D\Engine\source\T3D\fx\ribbon.cpp (6 hits)
	Line 338: void Ribbon::addSegmentPoint(Point3F &point, MatrixF &mat) {
	Line 342:    MatrixF xform(true);
	Line 501:    MatrixF *proj = renderPass->allocUniqueXform(MatrixF( true ));
	Line 501:    MatrixF *proj = renderPass->allocUniqueXform(MatrixF( true ));
	Line 504:    ri->objectToWorld = &MatrixF::Identity;
	Line 505:    ri->worldToCamera = &MatrixF::Identity;
  G:\Torque3D\Engine\source\T3D\fx\ribbon.h (1 hit)
	Line 132:    void addSegmentPoint(Point3F &point, MatrixF &mat);
  G:\Torque3D\Engine\source\T3D\fx\ribbonNode.cpp (3 hits)
	Line 181:       MatrixF mat;
	Line 197:    MatrixF trans(getTransform());
	Line 241:       MatrixF temp;
  G:\Torque3D\Engine\source\T3D\fx\splash.cpp (2 hits)
	Line 567:       MatrixF temp;
	Line 668:    MatrixF trans = getTransform();
  G:\Torque3D\Engine\source\T3D\gameBase\gameBase.h (4 hits)
	Line 423:    virtual void getCameraTransform (F32 *pos, MatrixF *mat ) { *mat = MatrixF::Identity; }
	Line 423:    virtual void getCameraTransform (F32 *pos, MatrixF *mat ) { *mat = MatrixF::Identity; }
	Line 424:    virtual void getEyeCameraTransform ( IDisplayDevice *device, U32 eyeId, MatrixF *mat ) { *mat = MatrixF::Identity; }
	Line 424:    virtual void getEyeCameraTransform ( IDisplayDevice *device, U32 eyeId, MatrixF *mat ) { *mat = MatrixF::Identity; }
  G:\Torque3D\Engine\source\T3D\gameBase\gameConnection.cpp (8 hits)
	Line 631: static MatrixF* sChaseQueue = 0;
	Line 635: bool GameConnection::getControlCameraTransform(F32 dt, MatrixF* mat)
	Line 668:       MatrixF& hm = sChaseQueue[sChaseQueueHead];
	Line 669:       MatrixF& tm = sChaseQueue[sChaseQueueTail];
	Line 684: bool GameConnection::getControlCameraEyeTransforms(IDisplayDevice *display, MatrixF *transforms)
	Line 1526: void GameConnection::play3D(SFXProfile* profile, const MatrixF *transform)
	Line 1998:    MatrixF mat = location.getMatrix();
	Line 2017:          sChaseQueue = new MatrixF[size];
  G:\Torque3D\Engine\source\T3D\gameBase\gameConnection.h (5 hits)
	Line 50: class MatrixF;
	Line 51: class MatrixF;
	Line 267:    bool getControlCameraTransform(F32 dt,MatrixF* mat);
	Line 272:    bool getControlCameraEyeTransforms(IDisplayDevice *display, MatrixF *transforms);
	Line 339:    void play3D(SFXProfile *profile, const MatrixF *transform);
  G:\Torque3D\Engine\source\T3D\gameBase\gameConnectionEvents.cpp (1 hit)
	Line 308: Sim3DAudioEvent::Sim3DAudioEvent(SFXProfile *profile,const MatrixF* mat)
  G:\Torque3D\Engine\source\T3D\gameBase\gameConnectionEvents.h (2 hits)
	Line 124:    MatrixF mTransform;
	Line 128:    Sim3DAudioEvent(SFXProfile *profile=NULL,const MatrixF* mat=NULL);
  G:\Torque3D\Engine\source\T3D\gameFunctions.cpp (1 hit)
	Line 169: bool GameGetCameraTransform(MatrixF *mat, Point3F *velocity)
  G:\Torque3D\Engine\source\T3D\gameFunctions.h (1 hit)
	Line 49: bool GameGetCameraTransform(MatrixF *mat, Point3F *velocity);
  G:\Torque3D\Engine\source\T3D\gameTSCtrl.cpp (1 hit)
	Line 146:    MatrixF mat;
  G:\Torque3D\Engine\source\T3D\groundPlane.cpp (4 hits)
	Line 124:    Parent::setTransform( MatrixF::Identity );
	Line 165: void GroundPlane::setTransform( const MatrixF &mat )
	Line 294:    polyList->setTransform( &MatrixF::Identity, Point3F( 1.0f, 1.0f, 1.0f ) );
	Line 369:    ri->objectToWorld          = pass->allocUniqueXform( MatrixF::Identity );
  G:\Torque3D\Engine\source\T3D\groundPlane.h (1 hit)
	Line 74:    virtual void      setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\T3D\guiMaterialPreview.cpp (4 hits)
	Line 286: 	MatrixF xRot, zRot;
	Line 368:    Frustum frust( isOrtho, left, right, bottom, top, nearPlane, farPlane, MatrixF::Identity );
	Line 394:    renderPass->assignSharedXform(RenderPassManager::View, MatrixF::Identity);
	Line 407:       MatrixF mat;
  G:\Torque3D\Engine\source\T3D\guiMaterialPreview.h (1 hit)
	Line 66:    MatrixF     mCameraMatrix;
  G:\Torque3D\Engine\source\T3D\guiObjectView.cpp (5 hits)
	Line 449:    MatrixF xRot, zRot;
	Line 492:    MatrixF modelview;
	Line 493:    MatrixF mv;
	Line 517:    Frustum frust( false, left, right, top, bottom, nearPlane, farPlane, MatrixF::Identity );
	Line 523:       SceneCameraState( GFX->getViewport(), frust, MatrixF::Identity, GFX->getProjectionMatrix() ),
  G:\Torque3D\Engine\source\T3D\guiObjectView.h (2 hits)
	Line 85:       MatrixF mCameraMatrix;
	Line 120:       MatrixF mMountTransform;
  G:\Torque3D\Engine\source\T3D\item.cpp (11 hits)
	Line 394:          colShape->addBox( mObjBox.getExtents() * 0.5f, MatrixF::Identity );
	Line 572:       MatrixF mat = mObjToWorld;
	Line 617:    MatrixF mat = mRenderObjToWorld;
	Line 626: void Item::setTransform(const MatrixF& mat)
	Line 630:    MatrixF tmat;
	Line 747:    MatrixF collisionMatrix(true);
	Line 968:    MatrixF mat = mObjToWorld;
	Line 1028: static MatrixF IMat(1);
	Line 1107:    MatrixF mat = mObjToWorld;
	Line 1380:       MatrixF rotMatrix;
	Line 1389:       MatrixF mat = mRenderObjToWorld;
  G:\Torque3D\Engine\source\T3D\item.h (1 hit)
	Line 185:    virtual void setTransform(const MatrixF &mat);
  G:\Torque3D\Engine\source\T3D\lightAnimData.cpp (2 hits)
	Line 287:    MatrixF transform( state->transform );
	Line 295:       MatrixF rot( euler );
  G:\Torque3D\Engine\source\T3D\lightAnimData.h (1 hit)
	Line 74:    MatrixF transform;
  G:\Torque3D\Engine\source\T3D\lightBase.cpp (2 hits)
	Line 184: void LightBase::setTransform( const MatrixF &mat )
	Line 262:       MatrixF mat( true );
  G:\Torque3D\Engine\source\T3D\lightBase.h (1 hit)
	Line 119:    virtual void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\T3D\lightDescription.cpp (2 hits)
	Line 204: void LightDescription::submitLight( LightState *state, const MatrixF &xfm, LightManager *lm, SimObject *object )
	Line 231: void LightDescription::prepRender( SceneRenderState *sceneState, LightState *lightState, const MatrixF &xfm )
  G:\Torque3D\Engine\source\T3D\lightDescription.h (2 hits)
	Line 95:    void submitLight( LightState *state, const MatrixF &xfm, LightManager *lm, SimObject *object );
	Line 96:    void prepRender( SceneRenderState *sceneState, LightState *lightState, const MatrixF &xfm );
  G:\Torque3D\Engine\source\T3D\lightFlareData.cpp (4 hits)
	Line 58:    lightMat = MatrixF::Identity;
	Line 279:    MatrixF projMatrix;
	Line 595:    ri->modelViewProj = &MatrixF::Identity;
	Line 596:    ri->bbModelViewProj = &MatrixF::Identity;
  G:\Torque3D\Engine\source\T3D\lightFlareData.h (1 hit)
	Line 61:    MatrixF lightMat;
  G:\Torque3D\Engine\source\T3D\missionMarker.cpp (2 hits)
	Line 149: void MissionMarker::setTransform(const MatrixF& mat)
	Line 172:       MatrixF mat;
  G:\Torque3D\Engine\source\T3D\missionMarker.h (1 hit)
	Line 73:       void setTransform(const MatrixF &mat);
  G:\Torque3D\Engine\source\T3D\occlusionVolume.cpp (2 hits)
	Line 121: void OcclusionVolume::setTransform( const MatrixF& mat )
	Line 153:       MatrixF camView( true );
  G:\Torque3D\Engine\source\T3D\occlusionVolume.h (1 hit)
	Line 75:       virtual void setTransform( const MatrixF& mat );
  G:\Torque3D\Engine\source\T3D\pathCamera.cpp (6 hits)
	Line 126:    MatrixF mat(1);
	Line 223:    MatrixF mat;
	Line 233:    MatrixF mat;
	Line 238: void PathCamera::interpolateMat(F32 pos,MatrixF* mat)
	Line 287: void PathCamera::getCameraTransform(F32* pos, MatrixF* mat)
	Line 302:    MatrixF mat;
  G:\Torque3D\Engine\source\T3D\pathCamera.h (2 hits)
	Line 90:    void interpolateMat(F32 pos,MatrixF* mat);
	Line 113:    void getCameraTransform(F32* pos,MatrixF* mat);
  G:\Torque3D\Engine\source\T3D\physicalZone.cpp (6 hits)
	Line 182: void PhysicalZone::setTransform(const MatrixF & mat)
	Line 186:       MatrixF base(true);
	Line 227:    MatrixF mat = getRenderTransform();
	Line 287:       MatrixF temp;
	Line 348:    MatrixF xform = getTransform();
	Line 354:    MatrixF base(true);
  G:\Torque3D\Engine\source\T3D\physicalZone.h (1 hit)
	Line 81:    void setTransform(const MatrixF &mat);
  G:\Torque3D\Engine\source\T3D\physics\bullet\btBody.cpp (19 hits)
	Line 87:    MatrixF localXfm = mColShape->getLocalTransform();
	Line 115:          localXfm = btCast<MatrixF>( principal );
	Line 129:       mCenterOfMass = new MatrixF( localXfm );
	Line 130:       mInvCenterOfMass = new MatrixF( *mCenterOfMass );
	Line 200:    MatrixF trans;
	Line 202:       trans.mul( btCast<MatrixF>( mActor->getCenterOfMassTransform() ), *mInvCenterOfMass );
	Line 204:       trans = btCast<MatrixF>( mActor->getCenterOfMassTransform() );
	Line 282: MatrixF& BtBody::getTransform( MatrixF *outMatrix )
	Line 282: MatrixF& BtBody::getTransform( MatrixF *outMatrix )
	Line 287:       outMatrix->mul( *mInvCenterOfMass, btCast<MatrixF>( mActor->getCenterOfMassTransform() ) );
	Line 289:       *outMatrix = btCast<MatrixF>( mActor->getCenterOfMassTransform() );
	Line 294: void BtBody::setTransform( const MatrixF &transform )
	Line 300:       MatrixF xfm;
	Line 318: void BtBody::applyCorrection( const MatrixF &transform )
	Line 325:       MatrixF xfm;
	Line 339:    MatrixF trans = btCast<MatrixF>( mActor->getCenterOfMassTransform() );
	Line 339:    MatrixF trans = btCast<MatrixF>( mActor->getCenterOfMassTransform() );
	Line 388: void BtBody::moveKinematicTo(const MatrixF &transform)
	Line 402:       MatrixF xfm;
  G:\Torque3D\Engine\source\T3D\physics\bullet\btBody.h (7 hits)
	Line 70:    MatrixF *mCenterOfMass;
	Line 73:    MatrixF *mInvCenterOfMass;
	Line 85:    virtual void setTransform( const MatrixF &xfm );
	Line 86:    virtual MatrixF& getTransform( MatrixF *outMatrix );
	Line 86:    virtual MatrixF& getTransform( MatrixF *outMatrix );
	Line 112:    virtual void applyCorrection( const MatrixF &xfm );
	Line 116:    virtual void moveKinematicTo(const MatrixF &xfm);
  G:\Torque3D\Engine\source\T3D\physics\bullet\btCasts.h (3 hits)
	Line 70: inline btTransform btCast( const MatrixF &xfm )
	Line 81: inline MatrixF btCast( const btTransform &xfm )
	Line 83:    MatrixF out;
  G:\Torque3D\Engine\source\T3D\physics\bullet\btCollision.cpp (10 hits)
	Line 60: void BtCollision::_addShape( btCollisionShape *shape, const MatrixF &localXfm )
	Line 85:       mLocalXfm = MatrixF::Identity;
	Line 96:    _addShape( shape, MatrixF::Identity );
	Line 100:                            const MatrixF &localXfm )
	Line 108:                               const MatrixF &localXfm )
	Line 117:                               const MatrixF &localXfm )
	Line 126:                               const MatrixF &localXfm )
	Line 138:                                     const MatrixF &localXfm )
	Line 164:                                     const MatrixF &localXfm )
	Line 199:    MatrixF offsetXfm( true );
  G:\Torque3D\Engine\source\T3D\physics\bullet\btCollision.h (9 hits)
	Line 53:    MatrixF mLocalXfm;
	Line 60:    void _addShape( btCollisionShape *shape, const MatrixF &localXfm );
	Line 72:    const MatrixF& getLocalTransform() const { return mLocalXfm; }
	Line 77:                         const MatrixF &localXfm );
	Line 79:                            const MatrixF &localXfm );
	Line 82:                               const MatrixF &localXfm );
	Line 85:                            const MatrixF &localXfm );
	Line 90:                                  const MatrixF &localXfm );
	Line 95:                                  const MatrixF &localXfm );
  G:\Torque3D\Engine\source\T3D\physics\bullet\btPlayer.cpp (4 hits)
	Line 497: void BtPlayer::setTransform( const MatrixF &transform )
	Line 507: MatrixF& BtPlayer::getTransform( MatrixF *outMatrix )
	Line 507: MatrixF& BtPlayer::getTransform( MatrixF *outMatrix )
	Line 511:    *outMatrix = btCast<MatrixF>( mGhostObject->getWorldTransform() );
  G:\Torque3D\Engine\source\T3D\physics\bullet\btPlayer.h (3 hits)
	Line 85:    virtual void setTransform( const MatrixF &transform );
	Line 86:    virtual MatrixF& getTransform( MatrixF *outMatrix );
	Line 86:    virtual MatrixF& getTransform( MatrixF *outMatrix );
  G:\Torque3D\Engine\source\T3D\physics\physicsBody.h (2 hits)
	Line 112:    virtual void applyCorrection( const MatrixF &xfm ) = 0;
	Line 122:    virtual void moveKinematicTo(const MatrixF &xfm) = 0;
  G:\Torque3D\Engine\source\T3D\physics\physicsCollision.h (7 hits)
	Line 31: class MatrixF;
	Line 56:                         const MatrixF &localXfm ) = 0;
	Line 60:                            const MatrixF &localXfm ) = 0;
	Line 65:                               const MatrixF &localXfm ) = 0;
	Line 70:                            const MatrixF &localXfm ) = 0;
	Line 77:                                  const MatrixF &localXfm ) = 0;
	Line 84:                                  const MatrixF &localXfm ) = 0;
  G:\Torque3D\Engine\source\T3D\physics\physicsCommon.h (2 hits)
	Line 113:    inline MatrixF getTransform() const
	Line 115:       MatrixF xfm;
  G:\Torque3D\Engine\source\T3D\physics\physicsDebris.cpp (8 hits)
	Line 290:                                        const MatrixF &transform,
	Line 417:    MatrixF mat;
	Line 520:    const MatrixF &objectXfm = getRenderWorldTransform();
	Line 521:    Vector<MatrixF> &nodeXfms = mShapeInstance->mNodeTransforms;
	Line 523:    MatrixF globalXfm;
	Line 524:    MatrixF tempXfm;
	Line 579:    MatrixF mat = getRenderTransform();
	Line 637:    MatrixF bodyMat( true );
  G:\Torque3D\Engine\source\T3D\physics\physicsDebris.h (1 hit)
	Line 121:                                  const MatrixF &transform,
  G:\Torque3D\Engine\source\T3D\physics\physicsForce.cpp (3 hits)
	Line 120:    MatrixF mat( true );
	Line 155:       MatrixF test( true );
	Line 159:       MatrixF mat( true );
  G:\Torque3D\Engine\source\T3D\physics\physicsObject.h (4 hits)
	Line 37: class MatrixF;
	Line 57:    virtual void setTransform( const MatrixF &transform ) = 0;
	Line 61:    virtual MatrixF& getTransform( MatrixF *outMatrix ) = 0;
	Line 61:    virtual MatrixF& getTransform( MatrixF *outMatrix ) = 0;
  G:\Torque3D\Engine\source\T3D\physics\physicsShape.cpp (7 hits)
	Line 315:    polyList.setTransform( &MatrixF::Identity, Point3F::One );
	Line 376:                            MatrixF::Identity );
	Line 396:       mResetPos( MatrixF::Identity ),
	Line 515:       MatrixF mat;
	Line 813: void PhysicsShape::setTransform( const MatrixF &newMat )
	Line 1063:    MatrixF mat = getRenderTransform();
	Line 1096:    const MatrixF &mat = getTransform();
  G:\Torque3D\Engine\source\T3D\physics\physicsShape.h (3 hits)
	Line 161:    MatrixF mResetPos;
	Line 205:    void _applyCorrection( const MatrixF &mat );
	Line 244:    void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\T3D\physics\physx\pxBody.cpp (4 hits)
	Line 289: MatrixF& PxBody::getTransform( MatrixF *outMatrix )
	Line 289: MatrixF& PxBody::getTransform( MatrixF *outMatrix )
	Line 356: void PxBody::setTransform( const MatrixF &transform )
	Line 377: void PxBody::applyCorrection( const MatrixF &transform )
  G:\Torque3D\Engine\source\T3D\physics\physx\pxBody.h (5 hits)
	Line 64:    MatrixF mInternalTransform;
	Line 83:    virtual void setTransform( const MatrixF &xfm );
	Line 84:    virtual MatrixF& getTransform( MatrixF *outMatrix );
	Line 84:    virtual MatrixF& getTransform( MatrixF *outMatrix );
	Line 110:    virtual void applyCorrection( const MatrixF &xfm );
  G:\Torque3D\Engine\source\T3D\physics\physx\pxCloth.cpp (4 hits)
	Line 299:       MatrixF mat;
	Line 364: void PxCloth::_recreateCloth( const MatrixF &transform )
	Line 376: void PxCloth::setTransform( const MatrixF &mat )
	Line 421:    ri->objectToWorld = &MatrixF::Identity;
  G:\Torque3D\Engine\source\T3D\physics\physx\pxCloth.h (3 hits)
	Line 81:    virtual void setTransform( const MatrixF &mat );
	Line 154:    MatrixF mResetXfm;
	Line 163:    void _recreateCloth( const MatrixF &transform );
  G:\Torque3D\Engine\source\T3D\physics\physx\pxCollision.cpp (6 hits)
	Line 79:                            const MatrixF &localXfm )
	Line 89:                               const MatrixF &localXfm )
	Line 100:                               const MatrixF &localXfm )
	Line 112:                               const MatrixF &localXfm )
	Line 163:                                     const MatrixF &localXfm )
	Line 216:                                     const MatrixF &localXfm )
  G:\Torque3D\Engine\source\T3D\physics\physx\pxCollision.h (7 hits)
	Line 44:    //void _addShape( btCollisionShape *shape, const MatrixF &localXfm );
	Line 57:                         const MatrixF &localXfm );
	Line 59:                            const MatrixF &localXfm );
	Line 62:                               const MatrixF &localXfm );
	Line 65:                            const MatrixF &localXfm );
	Line 70:                                  const MatrixF &localXfm );
	Line 75:                                  const MatrixF &localXfm );
  G:\Torque3D\Engine\source\T3D\physics\physx\pxFluid.cpp (2 hits)
	Line 135:       MatrixF mat;
	Line 153: void PxFluid::setTransform( const MatrixF &mat )
  G:\Torque3D\Engine\source\T3D\physics\physx\pxFluid.h (1 hit)
	Line 81:    virtual void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\T3D\physics\physx\pxMultiActor.cpp (24 hits)
	Line 855: bool PxMultiActor::_createActors( const MatrixF &xfm )
	Line 1389:    MatrixF mat = getRenderTransform();
	Line 1410:       MatrixF mat = getRenderTransform();
	Line 1533:       MatrixF mat;
	Line 1541:       MatrixF mat;
	Line 1601: void PxMultiActor::applyWarp( const MatrixF& newMat, bool interpRender, bool sweep )
	Line 1619:       MatrixF tMat;
	Line 1685:    MatrixF transform( object->getTransform() );
	Line 1705:    MatrixF transform( object->getTransform() );
	Line 1722: void PxMultiActor::setTransform( const MatrixF& mat )
	Line 1742: bool PxMultiActor::_getNodeTransform( U32 nodeIdx, MatrixF *outXfm )
	Line 1788:    MatrixF actorMat;
	Line 1791:    MatrixF nmat;
	Line 1799: void PxMultiActor::getMountTransform(U32 mountPoint,MatrixF* mat)
	Line 1812: void PxMultiActor::getRenderMountTransform(U32 mountPoint,MatrixF* mat)
	Line 1854:    MatrixF mat;
	Line 1929:       MatrixF interpMat;
	Line 1953: void PxMultiActor::sweepTest( MatrixF *mat )
	Line 1998: void PxMultiActor::applyCorrection( const MatrixF& mat, const NxVec3& linVel, const NxVec3& angVel )
	Line 2098:    Vector<MatrixF> *torqueXfms = &mShapeInstance->mNodeTransforms;
	Line 2099:    const MatrixF &objectXfm = getRenderWorldTransform();
	Line 2116:    MatrixF globalXfm;
	Line 2117:    MatrixF mat, tmp;
	Line 2479:    MatrixF tMat;
  G:\Torque3D\Engine\source\T3D\physics\physx\pxMultiActor.h (8 hits)
	Line 254:    void setTransform( const MatrixF &mat );
	Line 257:    virtual void getMountTransform( U32 mountPoint, MatrixF *mat );
	Line 258:    virtual void getRenderMountTransform( U32 index, MatrixF *mat );
	Line 294:    void applyWarp( const MatrixF& mat, bool interpRender, bool sweep );
	Line 303:    bool _createActors( const MatrixF &xfm );
	Line 332:    bool _getNodeTransform( U32 nodeIdx, MatrixF *outXfm );
	Line 369:    MatrixF mResetXfm;
	Line 377:    //Vector<MatrixF> mRelXfms;
  G:\Torque3D\Engine\source\T3D\physics\physx\pxPlayer.cpp (3 hits)
	Line 394: void PxPlayer::setTransform( const MatrixF &transform )
	Line 409: MatrixF& PxPlayer::getTransform( MatrixF *outMatrix )
	Line 409: MatrixF& PxPlayer::getTransform( MatrixF *outMatrix )
  G:\Torque3D\Engine\source\T3D\physics\physx\pxPlayer.h (3 hits)
	Line 83:    virtual void setTransform( const MatrixF &transform );
	Line 84:    virtual MatrixF& getTransform( MatrixF *outMatrix );
	Line 84:    virtual MatrixF& getTransform( MatrixF *outMatrix );
  G:\Torque3D\Engine\source\T3D\physics\physx\pxUtils.cpp (3 hits)
	Line 49:    MatrixF actorMat(true);
	Line 70:       MatrixF shapeMat(true);
	Line 92:             shapeMat.mul( MatrixF( EulerF( mDegToRad(90.0f), mDegToRad(90.0f), 0 ) ) );
  G:\Torque3D\Engine\source\T3D\physics\physx3\px3Body.cpp (6 hits)
	Line 311: MatrixF& Px3Body::getTransform( MatrixF *outMatrix )
	Line 311: MatrixF& Px3Body::getTransform( MatrixF *outMatrix )
	Line 315:    *outMatrix = px3Cast<MatrixF>(mActor->getGlobalPose());
	Line 367: void Px3Body::setTransform( const MatrixF &transform )
	Line 393: void Px3Body::applyCorrection( const MatrixF &transform )
	Line 426: void Px3Body::moveKinematicTo(const MatrixF &transform)
  G:\Torque3D\Engine\source\T3D\physics\physx3\px3Body.h (6 hits)
	Line 69:    MatrixF mInternalTransform;
	Line 90:    virtual void setTransform( const MatrixF &xfm );
	Line 91:    virtual MatrixF& getTransform( MatrixF *outMatrix );
	Line 91:    virtual MatrixF& getTransform( MatrixF *outMatrix );
	Line 118:    virtual void applyCorrection( const MatrixF &xfm );
	Line 123:    virtual void moveKinematicTo(const MatrixF &xfm);
  G:\Torque3D\Engine\source\T3D\physics\physx3\px3Casts.h (3 hits)
	Line 111: inline physx::PxTransform px3Cast( const MatrixF &xfm )
	Line 129: inline MatrixF px3Cast( const physx::PxTransform &xfm )
	Line 131:    MatrixF out;
  G:\Torque3D\Engine\source\T3D\physics\physx3\px3Collision.cpp (6 hits)
	Line 61: void Px3Collision::addBox( const Point3F &halfWidth,const MatrixF &localXfm )
	Line 70:                               const MatrixF &localXfm )
	Line 80:                               const MatrixF &localXfm )
	Line 90:                               const MatrixF &localXfm )
	Line 121:                                     const MatrixF &localXfm )
	Line 153:                                     const MatrixF &localXfm )
  G:\Torque3D\Engine\source\T3D\physics\physx3\px3Collision.h (6 hits)
	Line 66:                         const MatrixF &localXfm );
	Line 68:                            const MatrixF &localXfm );
	Line 71:                               const MatrixF &localXfm );
	Line 74:                            const MatrixF &localXfm );
	Line 79:                                  const MatrixF &localXfm );
	Line 84:                                  const MatrixF &localXfm );
  G:\Torque3D\Engine\source\T3D\physics\physx3\px3Player.cpp (3 hits)
	Line 292: void Px3Player::setTransform( const MatrixF &transform )
	Line 307: MatrixF& Px3Player::getTransform( MatrixF *outMatrix )
	Line 307: MatrixF& Px3Player::getTransform( MatrixF *outMatrix )
  G:\Torque3D\Engine\source\T3D\physics\physx3\px3Player.h (3 hits)
	Line 81:    virtual void setTransform( const MatrixF &transform );
	Line 82:    virtual MatrixF& getTransform( MatrixF *outMatrix );
	Line 82:    virtual MatrixF& getTransform( MatrixF *outMatrix );
  G:\Torque3D\Engine\source\T3D\player.cpp (62 hits)
	Line 2191:          MatrixF curTrans = getRenderTransform();
	Line 2677:    MatrixF zRot;
	Line 2900:       MatrixF xRot, zRot;
	Line 2903:       MatrixF rot;
	Line 3196: bool Player::checkDismountPosition(const MatrixF& oldMat, const MatrixF& mat)
	Line 3196: bool Player::checkDismountPosition(const MatrixF& oldMat, const MatrixF& mat)
	Line 3487:    MatrixF  mat;
	Line 3524: MatrixF * Player::Death::fallToGround(F32 dt, const Point3F& loc, F32 curZ, F32 boxRad)
	Line 3531:    MatrixF  *  retVal = NULL;
	Line 3588:          MatrixF  mat(true);
	Line 3597:          static MatrixF resMat(true);
	Line 3803:          MatrixF mat = getRenderTransform();
	Line 4636:    MatrixF collisionMatrix(true);
	Line 5316:    MatrixF mat;
	Line 5319:       //MatrixF nmat,zrot;
	Line 5338:    MatrixF mat;
	Line 5341:       //MatrixF nmat,zrot;
	Line 5354:          if (MatrixF * fallMat = mDeath.fallToGround(dt, pos, rot.z, boxRad))
	Line 5365: void Player::setTransform(const MatrixF& mat)
	Line 5379: void Player::getEyeTransform(MatrixF* mat)
	Line 5407:       MatrixF mountTransform = image->shapeInstance[shapeIndex]->mNodeTransforms[data->eyeMountNode[shapeIndex]];
	Line 5413:       MatrixF xfm(true);
	Line 5419: void Player::getEyeBaseTransform(MatrixF* mat, bool includeBank)
	Line 5423:    MatrixF pmat,xmat,zmat;
	Line 5438:       MatrixF imat;
	Line 5440:       MatrixF ymat;
	Line 5452:    MatrixF eyeMat(true);
	Line 5472: void Player::getRenderEyeTransform(MatrixF* mat)
	Line 5487:             MatrixF mountTransform = image.shapeInstance[shapeIndex]->mNodeTransforms[data.eyeMountNode[shapeIndex]];
	Line 5493:             MatrixF xfm(true);
	Line 5503: void Player::getRenderEyeBaseTransform(MatrixF* mat, bool includeBank)
	Line 5507:    MatrixF pmat,xmat,zmat;
	Line 5518:       MatrixF imat;
	Line 5520:       MatrixF ymat;
	Line 5532:    MatrixF eyeMat(true);
	Line 5556: void Player::getMuzzleTransform(U32 imageSlot,MatrixF* mat)
	Line 5560:    MatrixF nmat;
	Line 5562:    MatrixF smat;
	Line 5644: void Player::getRenderMuzzleTransform(U32 imageSlot,MatrixF* mat)
	Line 5648:    MatrixF nmat;
	Line 5650:    MatrixF smat;
	Line 5687:    MatrixF mat;
	Line 5716:    MatrixF world;
	Line 5735:          MatrixF nmat;
	Line 5737:          MatrixF offsetMat = image.shapeInstance[imageShapeIndex]->mNodeTransforms[data.eyeMountNode[imageShapeIndex]];
	Line 5743:          MatrixF nmat;
	Line 5750:          MatrixF nmat;
	Line 5751:          MatrixF smat;
	Line 5768:       MatrixF nmat;
	Line 5769:       getRenderMountTransform( 0.0f, data.mountPoint, MatrixF::Identity, &nmat);
	Line 5792:    MatrixF nmat;
	Line 5799:       MatrixF xmat;
	Line 5801:       MatrixF result;
	Line 5811: void Player::getCameraParameters(F32 *min,F32* max,Point3F* off,MatrixF* rot)
	Line 5918: static MatrixF IMat(1);
	Line 6724:    MatrixF oldPosMat(true);
	Line 6726:    MatrixF posMat(true);
	Line 6829:    MatrixF nmat;
	Line 6830:    MatrixF smat;
	Line 6855:    MatrixF footMat = getTransform();
	Line 6903:       MatrixF mat = getTransform();
	Line 7086:       MatrixF trans = getTransform();
  G:\Torque3D\Engine\source\T3D\player.h (11 hits)
	Line 549:       MatrixF* fallToGround(F32 adjust, const Point3F& pos, F32 zrot, F32 boxRad);
	Line 684:    void setTransform(const MatrixF &mat);
	Line 685:    void getEyeTransform(MatrixF* mat);
	Line 686:    void getEyeBaseTransform(MatrixF* mat, bool includeBank);
	Line 687:    void getRenderEyeTransform(MatrixF* mat);
	Line 688:    void getRenderEyeBaseTransform(MatrixF* mat, bool includeBank);
	Line 690:    void getCameraParameters(F32 *min, F32 *max, Point3F *offset, MatrixF *rot);
	Line 691:    void getMuzzleTransform(U32 imageSlot,MatrixF* mat);
	Line 692:    void getRenderMuzzleTransform(U32 imageSlot,MatrixF* mat);   
	Line 733:    bool checkDismountPosition(const MatrixF& oldPos, const MatrixF& newPos);  ///< Is it safe to dismount here?
	Line 733:    bool checkDismountPosition(const MatrixF& oldPos, const MatrixF& newPos);  ///< Is it safe to dismount here?
  G:\Torque3D\Engine\source\T3D\portal.cpp (1 hit)
	Line 220: void Portal::setTransform( const MatrixF& mat )
  G:\Torque3D\Engine\source\T3D\portal.h (1 hit)
	Line 200:       virtual void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\T3D\prefab.cpp (2 hits)
	Line 167: void Prefab::setTransform(const MatrixF & mat)
	Line 402:    MatrixF mat( itr->value.mat );
  G:\Torque3D\Engine\source\T3D\prefab.h (3 hits)
	Line 75:    virtual void setTransform( const MatrixF &mat );
	Line 127:       MatrixF mat;
	Line 130:       Transform( const MatrixF& m, const VectorF& s ) : mat(m), scale(s) { }
  G:\Torque3D\Engine\source\T3D\projectile.cpp (8 hits)
	Line 778:    MatrixF initialTransform( true );
	Line 909:          MatrixF trans = getTransform();
	Line 937:          MatrixF trans = getTransform();
	Line 1005:          MatrixF xform(true);
	Line 1116:       MatrixF xform( true );
	Line 1196:    MatrixF xform( true );
	Line 1245:    MatrixF xform(true);
	Line 1427:    MatrixF mat = getRenderTransform();
  G:\Torque3D\Engine\source\T3D\proximityMine.cpp (4 hits)
	Line 366: void ProximityMine::setTransform( const MatrixF& mat )
	Line 385:    MatrixF mat( true );
	Line 535:          MatrixF xform( true );
	Line 665:          MatrixF mat = getRenderTransform();
  G:\Torque3D\Engine\source\T3D\proximityMine.h (1 hit)
	Line 114:    virtual void setTransform( const MatrixF& mat );
  G:\Torque3D\Engine\source\T3D\rigid.cpp (4 hits)
	Line 104:    MatrixF iv,qmat;
	Line 265:    MatrixF oldx,newx;
	Line 286: void Rigid::getTransform(MatrixF* mat)
	Line 292: void Rigid::setTransform(const MatrixF& mat)
  G:\Torque3D\Engine\source\T3D\rigid.h (5 hits)
	Line 44:    MatrixF objectInertia;        ///< Moment of inertia
	Line 45:    MatrixF invObjectInertia;     ///< Inverse moment of inertia
	Line 46:    MatrixF invWorldInertia;      ///< Inverse moment of inertia in world space
	Line 88:    void getTransform(MatrixF* mat);
	Line 89:    void setTransform(const MatrixF& mat);
  G:\Torque3D\Engine\source\T3D\rigidShape.cpp (10 hits)
	Line 859: void RigidShape::getCameraParameters(F32 *min,F32* max,Point3F* off,MatrixF* rot)
	Line 871: void RigidShape::getCameraTransform(F32* pos,MatrixF* mat)
	Line 886:    MatrixF rot;
	Line 891:    MatrixF eye;
	Line 900:       MatrixF cam(1);
	Line 993:    MatrixF mat;
	Line 1001:    MatrixF mat;
	Line 1007: void RigidShape::setTransform(const MatrixF& newMat)
	Line 1154:    MatrixF currTransform;
	Line 1192:    MatrixF mat,cmat;
  G:\Torque3D\Engine\source\T3D\rigidShape.h (4 hits)
	Line 218:    void setTransform(const MatrixF& mat);
	Line 220: //   virtual bool collideBody(const MatrixF& mat,Collision* info) = 0;
	Line 291:    void getCameraParameters(F32 *min, F32* max, Point3F* offset, MatrixF* rot);
	Line 292:    void getCameraTransform(F32* pos, MatrixF* mat);
  G:\Torque3D\Engine\source\T3D\sceneComponent\T3DSceneClient.cpp (3 hits)
	Line 74:    MatrixF mat = getTransform();
	Line 80: const MatrixF & T3DSolidSceneClient::getTransform()
	Line 87:       return MatrixF::smIdentity;
  G:\Torque3D\Engine\source\T3D\sceneComponent\T3DSceneClient.h (1 hit)
	Line 78:    const MatrixF & getTransform();
  G:\Torque3D\Engine\source\T3D\sceneComponent\T3DSceneComponent.cpp (4 hits)
	Line 113: void T3DSceneComponent::setTransform(const MatrixF & mat)
	Line 133:    MatrixF mat = getTransform3D()->getWorldMatrix();
	Line 187:             MatrixF mat;
	Line 268:          MatrixF mat;
  G:\Torque3D\Engine\source\T3D\sceneComponent\T3DSceneComponent.h (1 hit)
	Line 114:    void setTransform(const MatrixF & mat);
  G:\Torque3D\Engine\source\T3D\sceneComponent\T3DTransform.cpp (29 hits)
	Line 73: void Transform3D::setWorldMatrix(const MatrixF & world)
	Line 77:       MatrixF parentMatrix;
	Line 79:       MatrixF parentMatrixInv = parentMatrix;
	Line 81:       MatrixF localMat;
	Line 89: void Transform3D::setObjectMatrix(const MatrixF & objMatrix)
	Line 93:       MatrixF parentMatrix;
	Line 95:       MatrixF parentMatrixInv = parentMatrix;
	Line 97:       MatrixF localMat;
	Line 165: void Transform3DInPlace::getWorldMatrix(MatrixF & worldMat, bool includeLocalScale) const
	Line 171:       MatrixF localMat, parentMat;
	Line 178: void Transform3DInPlace::getObjectMatrix(MatrixF & objectMat, bool includeLocalScale) const
	Line 181:       objectMat = MatrixF::smIdentity;
	Line 186:       MatrixF localMat, parentMat;
	Line 193: void Transform3DInPlace::getLocalMatrix(MatrixF & localMat, bool includeLocalScale) const
	Line 201: void Transform3DInPlace::setLocalMatrix(const MatrixF & localMat)
	Line 226:       MatrixF mat;
	Line 245:       MatrixF mat;
	Line 263:       MatrixF mat;
	Line 277: void TSTransform3D::getWorldMatrix(MatrixF & worldMat, bool includeLocalScale) const
	Line 286:       MatrixF parentMat;
	Line 292: void TSTransform3D::getObjectMatrix(MatrixF & objectMat, bool includeLocalScale) const
	Line 295:       objectMat = MatrixF::smIdentity;
	Line 305:       MatrixF parentMat;
	Line 311: void TSTransform3D::getLocalMatrix(MatrixF & localMat, bool includeLocalScale) const
	Line 336: void TSTransform3D::setLocalMatrix(const MatrixF & localMatrix)
	Line 347: MatrixF & TSTransform3D::getTSLocal(MatrixF & mat) const
	Line 347: MatrixF & TSTransform3D::getTSLocal(MatrixF & mat) const
	Line 359:       MatrixF parentMat = _shapeInstance->mNodeTransforms[parentIdx];
	Line 382: void TSTransform3D::setNodeTransform(TSShapeInstance * si, S32 nodeIndex, MatrixF & localTransform)
  G:\Torque3D\Engine\source\T3D\sceneComponent\T3DTransform.h (23 hits)
	Line 45:    void setWorldMatrix(const MatrixF & world);
	Line 46:    void setObjectMatrix(const MatrixF & objMatrix);
	Line 47:    virtual void setLocalMatrix(const MatrixF & localMatrix) = 0;
	Line 49:    virtual void getWorldMatrix(MatrixF & worldMatrix, bool includeLocalScale) const = 0;
	Line 50:    virtual void getObjectMatrix(MatrixF & objectMatrix, bool includeLocalScale) const = 0;
	Line 51:    virtual void getLocalMatrix(MatrixF & localMatrix, bool includeLocalScale) const = 0;
	Line 53:    MatrixF getWorldMatrix() const
	Line 55:       MatrixF world;
	Line 60:    MatrixF getObjectMatrix() const
	Line 62:       MatrixF objMatrix;
	Line 67:    MatrixF getLocalMatrix() const
	Line 69:       MatrixF loc;
	Line 156:    void getWorldMatrix(MatrixF & worldMat, bool includeLocalScale) const;
	Line 157:    void getObjectMatrix(MatrixF & objectMat, bool includeLocalScale) const;
	Line 158:    void getLocalMatrix(MatrixF & localMat, bool includeLocalScale) const;
	Line 159:    void setLocalMatrix(const MatrixF & localMat);
	Line 186:    void getWorldMatrix(MatrixF & worldMat, bool includeLocalScale) const;
	Line 187:    void getObjectMatrix(MatrixF & objectMat, bool includeLocalScale) const;
	Line 188:    void getLocalMatrix(MatrixF & localMat, bool includeLocalScale) const;
	Line 189:    void setLocalMatrix(const MatrixF & localMatrix);
	Line 192:    void setNodeTransform(TSShapeInstance * si, S32 nodeIndex, MatrixF & localTransform);
	Line 208:    MatrixF & getTSLocal(MatrixF & mat) const;
	Line 208:    MatrixF & getTSLocal(MatrixF & mat) const;
  G:\Torque3D\Engine\source\T3D\sfx\sfx3DWorld.cpp (2 hits)
	Line 78: void SFX3DObject::getEarTransform( MatrixF& transform ) const
	Line 124:    MatrixF transform;
  G:\Torque3D\Engine\source\T3D\sfx\sfx3DWorld.h (1 hit)
	Line 54:       void getEarTransform( MatrixF& transform ) const;
  G:\Torque3D\Engine\source\T3D\sfx\sfxEmitter.cpp (3 hits)
	Line 395:       MatrixF mat;
	Line 690:    const MatrixF& transform = getTransform();
	Line 1114: void SFXEmitter::setTransform( const MatrixF &mat )
  G:\Torque3D\Engine\source\T3D\sfx\sfxEmitter.h (1 hit)
	Line 229:       void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\T3D\shapeBase.cpp (33 hits)
	Line 606:    MatrixF mat = txfm.getMatrix();
	Line 657:    MatrixF testMat(true);
	Line 1329:       MatrixF mat;
	Line 1393:       MatrixF mat;
	Line 1504:    MatrixF eyeTransform;
	Line 1767:    MatrixF trans = getTransform();
	Line 1870:    MatrixF xf(true);
	Line 1871:    getMountTransform( ShapeBaseData::AIRepairNode, MatrixF::Identity, &xf );
	Line 1879: void ShapeBase::getEyeTransform(MatrixF* mat)
	Line 1884: void ShapeBase::getEyeBaseTransform(MatrixF* mat, bool includeBank)
	Line 1894: void ShapeBase::getRenderEyeTransform(MatrixF* mat)
	Line 1899: void ShapeBase::getRenderEyeBaseTransform(MatrixF* mat, bool includeBank)
	Line 1909: void ShapeBase::getCameraTransform(F32* pos,MatrixF* mat)
	Line 1921:       MatrixF eye,rot;
	Line 1984: void ShapeBase::getEyeCameraTransform(IDisplayDevice *displayDevice, U32 eyeId, MatrixF *outMat)
	Line 1986:    MatrixF temp(1);
	Line 1996:    MatrixF cameraTransform(1);
	Line 2053: void ShapeBase::getCameraParameters(F32 *min,F32* max,Point3F* off,MatrixF* rot)
	Line 2609:       MatrixF mat = getRenderTransform();
	Line 2637:    MatrixF mat;
	Line 2669:          MatrixF mat;
	Line 3380: const MatrixF& ShapeBaseConvex::getTransform() const
	Line 3384:    const MatrixF& omat = (transform != 0)? *transform: mObject->getTransform();
	Line 3390:       static MatrixF mat;
	Line 3399:    const MatrixF& omat = (transform != 0)? *transform: mObject->getTransform();
	Line 3403: Box3F ShapeBaseConvex::getBoundingBox(const MatrixF& mat, const Point3F& scale) const
	Line 3432: void ShapeBaseConvex::getFeatures(const MatrixF& mat, const VectorF& n, ConvexFeature* cf)
	Line 4152:    MatrixF xf(true);
	Line 4154:       object->getMountTransform( slot, MatrixF::Identity, &xf );
	Line 4212:    MatrixF mat;
	Line 4229:    MatrixF mat;
	Line 4246:    MatrixF mat;
	Line 4265:    MatrixF mat;
  G:\Torque3D\Engine\source\T3D\shapeBase.h (31 hits)
	Line 102:    MatrixF*    nodeTransform;
	Line 105:    MatrixF*    transform;
	Line 121:    const MatrixF& getTransform() const;
	Line 123:    Box3F getBoundingBox(const MatrixF& mat, const Point3F& scale) const;
	Line 125:    void         getFeatures(const MatrixF& mat,const VectorF& n, ConvexFeature* cf);
	Line 376:    MatrixF           mountOffset;   ///< Mount point offset, so we know where the image is.
	Line 377:    MatrixF           eyeOffset;     ///< Offset from eye for first person.
	Line 409:    MatrixF mountTransform[MaxShapes];  ///< Transformation to get to the mountNode.
	Line 840:       void updateSoundSources(const MatrixF& renderTransform);  
	Line 1383:    virtual void getMountTransform( S32 index, const MatrixF &xfm, MatrixF *outMat );
	Line 1383:    virtual void getMountTransform( S32 index, const MatrixF &xfm, MatrixF *outMat );
	Line 1384:    virtual void getRenderMountTransform( F32 delta, S32 index, const MatrixF &xfm, MatrixF *outMat );
	Line 1384:    virtual void getRenderMountTransform( F32 delta, S32 index, const MatrixF &xfm, MatrixF *outMat );
	Line 1556:    bool getCorrectedAim(const MatrixF& muzMat, VectorF* result);
	Line 1579:    virtual void getCameraParameters(F32 *min,F32* max,Point3F* offset,MatrixF* rot);
	Line 1585:    virtual void getCameraTransform(F32* pos,MatrixF* mat);
	Line 1589:    virtual void getEyeCameraTransform( IDisplayDevice *display, U32 eyeId, MatrixF *outMat );
	Line 1606:    virtual void getEyeTransform(MatrixF* mat);
	Line 1610:    virtual void getEyeBaseTransform(MatrixF* mat, bool includeBank);
	Line 1618:    virtual void getRetractionTransform(U32 imageSlot,MatrixF* mat);
	Line 1623:    virtual void getMuzzleTransform(U32 imageSlot,MatrixF* mat);
	Line 1628:    virtual void getImageTransform(U32 imageSlot,MatrixF* mat);
	Line 1634:    virtual void getImageTransform(U32 imageSlot,S32 node, MatrixF* mat);
	Line 1640:    virtual void getImageTransform(U32 imageSlot, StringTableEntry nodeName, MatrixF* mat);
	Line 1655:    virtual void getRenderRetractionTransform(U32 index,MatrixF* mat);   
	Line 1656:    virtual void getRenderMuzzleTransform(U32 index,MatrixF* mat);   
	Line 1657:    virtual void getRenderImageTransform(U32 imageSlot,MatrixF* mat,bool noEyeOffset=false);
	Line 1658:    virtual void getRenderImageTransform(U32 index,S32 node, MatrixF* mat);
	Line 1659:    virtual void getRenderImageTransform(U32 index, StringTableEntry nodeName, MatrixF* mat);
	Line 1662:    virtual void getRenderEyeTransform(MatrixF* mat);
	Line 1663:    virtual void getRenderEyeBaseTransform(MatrixF* mat, bool includeBank);
  G:\Torque3D\Engine\source\T3D\shapeImage.cpp (50 hits)
	Line 496:             MatrixF total(1);
	Line 498:                MatrixF nmat;
	Line 1457: void ShapeBase::MountedImage::updateSoundSources( const MatrixF &renderTransform )
	Line 1771:    MatrixF mat;
	Line 1791:    MatrixF mat;
	Line 1799:    MatrixF mat;
	Line 1819:    MatrixF mat;
	Line 1842: void ShapeBase::getMountTransform( S32 index, const MatrixF &xfm, MatrixF *outMat )
	Line 1842: void ShapeBase::getMountTransform( S32 index, const MatrixF &xfm, MatrixF *outMat )
	Line 1848:          MatrixF mountTransform = mShapeInstance->mNodeTransforms[ni];
	Line 1867: void ShapeBase::getImageTransform(U32 imageSlot,MatrixF* mat)
	Line 1875:       MatrixF nmat;
	Line 1882:          MatrixF mountTransform = image.shapeInstance[shapeIndex]->mNodeTransforms[data.eyeMountNode[shapeIndex]];
	Line 1891:          getMountTransform( image.dataBlock->mountPoint, MatrixF::Identity, &nmat );
	Line 1899: void ShapeBase::getImageTransform(U32 imageSlot,S32 node,MatrixF* mat)
	Line 1910:          MatrixF nmat = image.shapeInstance[shapeIndex]->mNodeTransforms[node];
	Line 1911:          MatrixF mmat;
	Line 1918:             MatrixF emat;
	Line 1921:             MatrixF mountTransform = image.shapeInstance[shapeIndex]->mNodeTransforms[data.eyeMountNode[shapeIndex]];
	Line 1928:             MatrixF emat;
	Line 1934:             MatrixF emat;
	Line 1935:             getMountTransform( image.dataBlock->mountPoint, MatrixF::Identity, &emat );
	Line 1948: void ShapeBase::getImageTransform(U32 imageSlot,StringTableEntry nodeName,MatrixF* mat)
	Line 1953: void ShapeBase::getMuzzleTransform(U32 imageSlot,MatrixF* mat)
	Line 1966: void ShapeBase::getRenderMountTransform( F32 delta, S32 mountPoint, const MatrixF &xfm, MatrixF *outMat )
	Line 1966: void ShapeBase::getRenderMountTransform( F32 delta, S32 mountPoint, const MatrixF &xfm, MatrixF *outMat )
	Line 1972:          MatrixF mountTransform = mShapeInstance->mNodeTransforms[ni];
	Line 1993: void ShapeBase::getRenderImageTransform( U32 imageSlot, MatrixF* mat, bool noEyeOffset )
	Line 2002:       MatrixF nmat;
	Line 2006:          MatrixF mountTransform = image.shapeInstance[shapeIndex]->mNodeTransforms[data.eyeMountNode[shapeIndex]];
	Line 2017:          getRenderMountTransform( 0.0f, data.mountPoint, MatrixF::Identity, &nmat );
	Line 2025: void ShapeBase::getRenderImageTransform(U32 imageSlot,S32 node,MatrixF* mat)
	Line 2036:          MatrixF nmat = image.shapeInstance[shapeIndex]->mNodeTransforms[node];
	Line 2037:          MatrixF mmat;
	Line 2041:             MatrixF emat;
	Line 2044:             MatrixF mountTransform = image.shapeInstance[shapeIndex]->mNodeTransforms[data.eyeMountNode[shapeIndex]];
	Line 2051:             MatrixF emat;
	Line 2057:             MatrixF emat;
	Line 2058:             getRenderMountTransform( 0.0f, data.mountPoint, MatrixF::Identity, &emat );
	Line 2071: void ShapeBase::getRenderImageTransform(U32 imageSlot,StringTableEntry nodeName,MatrixF* mat)
	Line 2076: void ShapeBase::getRenderMuzzleTransform(U32 imageSlot,MatrixF* mat)
	Line 2087: void ShapeBase::getRetractionTransform(U32 imageSlot,MatrixF* mat)
	Line 2104: void ShapeBase::getRenderRetractionTransform(U32 imageSlot,MatrixF* mat)
	Line 2134: bool ShapeBase::getCorrectedAim(const MatrixF& muzzleMat, VectorF* result)
	Line 2141:    MatrixF  camMat;
	Line 3165:             MatrixF mat;
	Line 3311:          MatrixF imageMat;
	Line 3333:    MatrixF ejectTrans;
	Line 3340:    MatrixF ejectOrient = MathUtils::createOrientFromDir( ejectDir );
	Line 3350:    MatrixF imageTrans = getRenderTransform();
  G:\Torque3D\Engine\source\T3D\staticShape.cpp (2 hits)
	Line 237: void StaticShape::setTransform(const MatrixF& mat)
	Line 281:       MatrixF mat;
  G:\Torque3D\Engine\source\T3D\staticShape.h (1 hit)
	Line 78:    void setTransform(const MatrixF &mat);
  G:\Torque3D\Engine\source\T3D\trigger.cpp (8 hits)
	Line 503: void Trigger::setTransform(const MatrixF & mat)
	Line 511:       MatrixF base(true);
	Line 553:    MatrixF mat = getRenderTransform();
	Line 584:    MatrixF xform = getTransform();
	Line 592:    MatrixF base(true);
	Line 606:       MatrixF colMat( true );      
	Line 610:       //MatrixF colMat( true );
	Line 772:       MatrixF temp;
  G:\Torque3D\Engine\source\T3D\trigger.h (1 hit)
	Line 136:    void setTransform(const MatrixF &mat);
  G:\Torque3D\Engine\source\T3D\tsStatic.cpp (11 hits)
	Line 419:       MatrixF offset( true );
	Line 528:       MatrixF mat( true );
	Line 545:       MatrixF mat( true );
	Line 637:       MatrixF xfm( true );
	Line 651:    MatrixF mat = getRenderTransform();
	Line 700:    MatrixF mat = getRenderTransform();
	Line 726: void TSStatic::setTransform(const MatrixF & mat)
	Line 806:       MatrixF mat;
	Line 1102: Box3F TSStaticPolysoupConvex::getBoundingBox(const MatrixF& mat, const Point3F& scale) const
	Line 1111:    MatrixF i( mObject->getTransform() );
	Line 1129: void TSStaticPolysoupConvex::getFeatures(const MatrixF& mat,const VectorF& n, ConvexFeature* cf)
  G:\Torque3D\Engine\source\T3D\tsStatic.h (3 hits)
	Line 75:    Box3F getBoundingBox(const MatrixF& mat, const Point3F& scale) const;
	Line 77:    void getFeatures(const MatrixF& mat,const VectorF& n, ConvexFeature* cf);
	Line 217:    void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\T3D\turret\aiTurretShape.cpp (9 hits)
	Line 808:    MatrixF aimMat;
	Line 858:    MatrixF mat;
	Line 863:       MatrixF* nodeTrans = &mShapeInstance->mNodeTransforms[node];
	Line 869:       MatrixF nodeMat(true);
	Line 1033: void AITurretShape::setTransform(const MatrixF& mat)
	Line 1051:    MatrixF mat;
	Line 1056: void AITurretShape::getScanTransform(MatrixF& mat)
	Line 1069: void AITurretShape::getAimTransform(MatrixF& mat)
	Line 1216:    MatrixF nodeMat;
  G:\Torque3D\Engine\source\T3D\turret\aiTurretShape.h (5 hits)
	Line 244:    MatrixF   mScanWorkspaceScanMat;
	Line 245:    MatrixF   mScanWorkspaceScanWorldMat;
	Line 285:    virtual void setTransform(const MatrixF &mat);
	Line 286:    void getScanTransform(MatrixF& mat);
	Line 287:    void getAimTransform(MatrixF& mat);
  G:\Torque3D\Engine\source\T3D\turret\turretShape.cpp (44 hits)
	Line 643:       MatrixF mat;
	Line 682: void TurretShape::setTransform( const MatrixF& mat )
	Line 764: bool TurretShape::getNodeTransform(S32 node, MatrixF& mat)
	Line 769:    MatrixF nodeTransform = mShapeInstance->mNodeTransforms[node];
	Line 781: bool TurretShape::getWorldNodeTransform(S32 node, MatrixF& mat)
	Line 783:    MatrixF nodeMat;
	Line 810:       MatrixF* mat = &mShapeInstance->mNodeTransforms[node];
	Line 824:       MatrixF* mat = &mShapeInstance->mNodeTransforms[node];
	Line 840:          MatrixF* mat = &mShapeInstance->mNodeTransforms[node];
	Line 853:          MatrixF* mat = &mShapeInstance->mNodeTransforms[node];
	Line 892: void TurretShape::mountObject( SceneObject *obj, S32 node, const MatrixF &xfm )
	Line 944: void TurretShape::getCameraParameters(F32 *min,F32* max,Point3F* off,MatrixF* rot)
	Line 953: void TurretShape::getCameraTransform(F32* pos,MatrixF* mat)
	Line 967:    MatrixF rot;
	Line 972:    MatrixF eye;
	Line 978:       MatrixF cam(1);
	Line 1139: void TurretShape::getWeaponMountTransform( S32 index, const MatrixF &xfm, MatrixF *outMat )
	Line 1139: void TurretShape::getWeaponMountTransform( S32 index, const MatrixF &xfm, MatrixF *outMat )
	Line 1145:          MatrixF mountTransform = mShapeInstance->mNodeTransforms[ni];
	Line 1164: void TurretShape::getRenderWeaponMountTransform( F32 delta, S32 mountPoint, const MatrixF &xfm, MatrixF *outMat )
	Line 1164: void TurretShape::getRenderWeaponMountTransform( F32 delta, S32 mountPoint, const MatrixF &xfm, MatrixF *outMat )
	Line 1170:          MatrixF mountTransform = mShapeInstance->mNodeTransforms[ni];
	Line 1190: void TurretShape::getImageTransform(U32 imageSlot,MatrixF* mat)
	Line 1197:       MatrixF nmat;
	Line 1203:          getWeaponMountTransform( imageSlot, MatrixF::Identity, &nmat );
	Line 1211: void TurretShape::getRenderImageTransform( U32 imageSlot, MatrixF* mat, bool noEyeOffset )
	Line 1219:       MatrixF nmat;
	Line 1227:          getRenderWeaponMountTransform( 0.0f, imageSlot, MatrixF::Identity, &nmat );
	Line 1235: void TurretShape::getImageTransform(U32 imageSlot,S32 node,MatrixF* mat)
	Line 1248:          MatrixF nmat = image.shapeInstance[shapeIndex]->mNodeTransforms[node];
	Line 1249:          MatrixF mmat;
	Line 1256:             MatrixF emat;
	Line 1259:             MatrixF mountTransform = image.shapeInstance[shapeIndex]->mNodeTransforms[data.eyeMountNode[shapeIndex]];
	Line 1266:             MatrixF emat;
	Line 1272:             MatrixF emat;
	Line 1273:             getWeaponMountTransform( imageSlot, MatrixF::Identity, &emat );
	Line 1286: void TurretShape::getRenderImageTransform(U32 imageSlot,S32 node,MatrixF* mat)
	Line 1299:          MatrixF nmat = image.shapeInstance[shapeIndex]->mNodeTransforms[node];
	Line 1300:          MatrixF mmat;
	Line 1304:             MatrixF emat;
	Line 1307:             MatrixF mountTransform = image.shapeInstance[shapeIndex]->mNodeTransforms[data.eyeMountNode[shapeIndex]];
	Line 1314:             MatrixF emat;
	Line 1320:             MatrixF emat;
	Line 1321:             getRenderWeaponMountTransform( 0.0f, imageSlot, MatrixF::Identity, &emat );
  G:\Torque3D\Engine\source\T3D\turret\turretShape.h (15 hits)
	Line 183:    virtual void setTransform( const MatrixF &mat );
	Line 192:    bool getNodeTransform(S32 node, MatrixF& mat);
	Line 193:    bool getWorldNodeTransform(S32 node, MatrixF& mat);
	Line 200:    virtual void mountObject( SceneObject *obj, S32 node, const MatrixF &xfm = MatrixF::Identity );
	Line 200:    virtual void mountObject( SceneObject *obj, S32 node, const MatrixF &xfm = MatrixF::Identity );
	Line 203:    virtual void getCameraParameters(F32 *min,F32* max,Point3F* offset,MatrixF* rot);
	Line 204:    virtual void getCameraTransform(F32* pos,MatrixF* mat);
	Line 211:    virtual void getWeaponMountTransform( S32 index, const MatrixF &xfm, MatrixF *outMat );
	Line 211:    virtual void getWeaponMountTransform( S32 index, const MatrixF &xfm, MatrixF *outMat );
	Line 212:    virtual void getRenderWeaponMountTransform( F32 delta, S32 index, const MatrixF &xfm, MatrixF *outMat );
	Line 212:    virtual void getRenderWeaponMountTransform( F32 delta, S32 index, const MatrixF &xfm, MatrixF *outMat );
	Line 214:    virtual void getImageTransform(U32 imageSlot,MatrixF* mat);
	Line 215:    virtual void getRenderImageTransform(U32 imageSlot,MatrixF* mat,bool noEyeOffset=false);
	Line 217:    virtual void getImageTransform(U32 imageSlot,S32 node, MatrixF* mat);
	Line 218:    virtual void getRenderImageTransform(U32 imageSlot,S32 node, MatrixF* mat);
  G:\Torque3D\Engine\source\T3D\vehicles\flyingVehicle.cpp (3 hits)
	Line 147:       MatrixF imat(1);
	Line 483:    MatrixF currPosMat;
	Line 724:             MatrixF mat;
  G:\Torque3D\Engine\source\T3D\vehicles\flyingVehicle.h (1 hit)
	Line 172: //   bool collideBody(const MatrixF& mat,Collision* info);
  G:\Torque3D\Engine\source\T3D\vehicles\guiSpeedometer.cpp (1 hit)
	Line 177:    MatrixF newMat(1);
  G:\Torque3D\Engine\source\T3D\vehicles\hoverVehicle.cpp (3 hits)
	Line 675:    MatrixF currTransform;
	Line 805:             MatrixF tempMat(true);
	Line 960:             MatrixF mat;
  G:\Torque3D\Engine\source\T3D\vehicles\vehicle.cpp (11 hits)
	Line 1002: void Vehicle::getCameraParameters(F32 *min,F32* max,Point3F* off,MatrixF* rot)
	Line 1014: void Vehicle::getCameraTransform(F32* pos,MatrixF* mat)
	Line 1028:    MatrixF rot;
	Line 1033:    MatrixF eye;
	Line 1042:       MatrixF cam(1);
	Line 1191:    MatrixF mat;
	Line 1199:    MatrixF mat;
	Line 1205: void Vehicle::setTransform(const MatrixF& newMat)
	Line 1360:    MatrixF mat,cmat;
	Line 1815: void Vehicle::mountObject(SceneObject *obj, S32 node, const MatrixF &xfm )
	Line 1855:             MatrixF trans = getTransform();
  G:\Torque3D\Engine\source\T3D\vehicles\vehicle.h (6 hits)
	Line 229:    void setTransform(const MatrixF& mat);
	Line 231: //   virtual bool collideBody(const MatrixF& mat,Collision* info) = 0;
	Line 304:    void getCameraParameters(F32 *min, F32* max, Point3F* offset, MatrixF* rot);
	Line 305:    void getCameraTransform(F32* pos, MatrixF* mat);
	Line 310:    virtual void mountObject( SceneObject *obj, S32 node, const MatrixF &xfm = MatrixF::Identity );
	Line 310:    virtual void mountObject( SceneObject *obj, S32 node, const MatrixF &xfm = MatrixF::Identity );
  G:\Torque3D\Engine\source\T3D\vehicles\vehicleBlocker.cpp (1 hit)
	Line 114:    MatrixF mat;
  G:\Torque3D\Engine\source\T3D\vehicles\wheeledVehicle.cpp (13 hits)
	Line 400:       MatrixF imat(1);
	Line 737: void WheeledVehicle::getWheelInstAndTransform( U32 index, TSShapeInstance** inst, MatrixF* xfrm ) const
	Line 748:    MatrixF world = getRenderTransform();
	Line 752:    MatrixF hub(EulerF(0,0,mSteering.x * wheel->steering));
	Line 759:    MatrixF rot(EulerF(wheel->apos * M_2PI,0,0));
	Line 764:    MatrixF wrot(EulerF(0,0,(wheel->data->pos.x > 0)? M_PI/2: -M_PI/2));
	Line 858:    MatrixF currMatrix;
	Line 1133:    MatrixF currMatrix;
	Line 1357:          MatrixF mat = mObjToWorld;
	Line 1393:    MatrixF mat = getRenderTransform();
	Line 1405:          MatrixF hub(EulerF(0,0,mSteering.x * wheel->steering));
	Line 1413:          MatrixF rot(EulerF(wheel->apos * M_2PI,0,0));
	Line 1418:          MatrixF wrot(EulerF(0,0,(wheel->data->pos.x > 0)? M_PI/2: -M_PI/2));
  G:\Torque3D\Engine\source\T3D\vehicles\wheeledVehicle.h (1 hit)
	Line 241:    void getWheelInstAndTransform( U32 wheel, TSShapeInstance** inst, MatrixF* xfrm ) const;
  G:\Torque3D\Engine\source\terrain\terrCellMaterial.cpp (7 hits)
	Line 167: void TerrainCellMaterial::setTransformAndEye(   const MatrixF &modelXfm, 
	Line 168:                                                 const MatrixF &viewXfm,
	Line 169:                                                 const MatrixF &projectXfm,
	Line 174:    MatrixF modelViewProj = projectXfm * viewXfm * modelXfm;
	Line 176:    MatrixF invViewXfm( viewXfm );
	Line 180:    MatrixF invModelXfm( modelXfm );
	Line 197:          MatrixF worldViewOnly = viewXfm * modelXfm;
  G:\Torque3D\Engine\source\terrain\terrCellMaterial.h (3 hits)
	Line 190:    void setTransformAndEye(   const MatrixF &modelXfm, 
	Line 191:                               const MatrixF &viewXfm,
	Line 192:                               const MatrixF &projectXfm,
  G:\Torque3D\Engine\source\terrain\terrCollision.cpp (2 hits)
	Line 196: Box3F TerrainConvex::getBoundingBox(const MatrixF&, const Point3F& ) const
	Line 230: void TerrainConvex::getFeatures(const MatrixF& mat,const VectorF& n, ConvexFeature* cf)
  G:\Torque3D\Engine\source\terrain\terrCollision.h (2 hits)
	Line 51:    Box3F getBoundingBox(const MatrixF& mat, const Point3F& scale) const;
	Line 53:    void getFeatures(const MatrixF& mat,const VectorF& n, ConvexFeature* cf);
  G:\Torque3D\Engine\source\terrain\terrData.cpp (3 hits)
	Line 1041:       colShape->addHeightfield( mFile->getHeightMap().address(), holes, getBlockSize(), mSquareSize, MatrixF::Identity );
	Line 1090: void TerrainBlock::setTransform(const MatrixF & mat)
	Line 1212:       MatrixF mat;
  G:\Torque3D\Engine\source\terrain\terrData.h (1 hit)
	Line 431:    void setTransform( const MatrixF &mat );
  G:\Torque3D\Engine\source\terrain\terrRender.cpp (4 hits)
	Line 359:    MatrixF worldViewXfm = state->getWorldViewMatrix();
	Line 362:    MatrixF worldViewProjXfm = state->getProjectionMatrix();
	Line 365:    const MatrixF &objectXfm = getRenderWorldTransform();
	Line 410:    MatrixF *riObjectToWorldXfm = renderPass->allocUniqueXform( getRenderTransform() );
  G:\Torque3D\Engine\source\ts\arch\tsMeshIntrinsics.arch.h (4 hits)
	Line 29: extern void m_matF_x_BatchedVertWeightList_SSE(const MatrixF &mat, const dsize_t count, const TSSkinMesh::BatchData::BatchedVertWeight * __restrict batch, U8 * const __restrict outPtr, const dsize_t outStride);
	Line 31: extern void m_matF_x_BatchedVertWeightList_SSE4(const MatrixF &mat, const dsize_t count, const TSSkinMesh::BatchData::BatchedVertWeight * __restrict batch, U8 * const __restrict outPtr, const dsize_t outStride);
	Line 38: extern void m_matF_x_BatchedVertWeightList_X360(const MatrixF &mat, const dsize_t count, const TSSkinMesh::BatchData::BatchedVertWeight * __restrict batch, U8 * const __restrict outPtr, const dsize_t outStride);
	Line 41: extern void m_matF_x_BatchedVertWeightList_gccvec(const MatrixF &mat, const dsize_t count, const TSSkinMesh::BatchData::BatchedVertWeight * __restrict batch, U8 * const __restrict outPtr, const dsize_t outStride);
  G:\Torque3D\Engine\source\ts\arch\tsMeshIntrinsics.sse.cpp (2 hits)
	Line 70: void m_matF_x_BatchedVertWeightList_SSE(const MatrixF &mat, 
	Line 83:    MatrixF transMat;
  G:\Torque3D\Engine\source\ts\arch\tsMeshIntrinsics.sse4.cpp (1 hit)
	Line 28: void m_matF_x_BatchedVertWeightList_SSE4(const MatrixF &mat, 
  G:\Torque3D\Engine\source\ts\collada\colladaAppMesh.cpp (7 hits)
	Line 349: MatrixF ColladaAppMesh::getMeshTransform(F32 time)
	Line 626: void ColladaAppMesh::getVertexData(const domGeometry* geometry, F32 time, const MatrixF& objOffset,
	Line 758: void ColladaAppMesh::getMorphVertexData(const domMorph* morph, F32 time, const MatrixF& objOffset,
	Line 886: void ColladaAppMesh::lockMesh(F32 t, const MatrixF& objOffset)
	Line 953:    MatrixF invObjOffset(objectOffset);
	Line 957:    MatrixF bindShapeMatrix(true);
	Line 1085:       MatrixF invBind = streams.invBindMatrices.getMatrixFValue(iJoint);
  G:\Torque3D\Engine\source\ts\collada\colladaAppMesh.h (4 hits)
	Line 112:    void getVertexData(  const domGeometry* geometry, F32 time, const MatrixF& objOffset,
	Line 116:    void getMorphVertexData(   const domMorph* morph, F32 time, const MatrixF& objOffset,
	Line 215:    void lockMesh(F32 time, const MatrixF& objOffset);
	Line 222:    MatrixF getMeshTransform(F32 time);
  G:\Torque3D\Engine\source\ts\collada\colladaAppNode.cpp (5 hits)
	Line 178: MatrixF ColladaAppNode::getNodeTransform(F32 time)
	Line 187:       MatrixF nodeTransform = getTransform(time);
	Line 211: MatrixF ColladaAppNode::getTransform(F32 time)
	Line 232:       MatrixF mat(true);
	Line 234:       // Convert the transform element to a MatrixF
  G:\Torque3D\Engine\source\ts\collada\colladaAppNode.h (4 hits)
	Line 41:    MatrixF getTransform(F32 time);
	Line 56:    MatrixF                    lastTransform;          ///< Last transform lookup (getTransform)
	Line 58:    MatrixF                    defaultNodeTransform;   ///< Transform at DefaultTime
	Line 105:    MatrixF getNodeTransform(F32 time);
  G:\Torque3D\Engine\source\ts\collada\colladaExtensions.h (1 hit)
	Line 126:    MatrixF        textureTransform;
  G:\Torque3D\Engine\source\ts\collada\colladaLights.cpp (3 hits)
	Line 60: static void processNodeLights(AppNode* appNode, const MatrixF& offset, SimGroup* group)
	Line 119:       MatrixF mat(offset);
	Line 189:    MatrixF offset(true);
  G:\Torque3D\Engine\source\ts\collada\colladaUtils.cpp (3 hits)
	Line 48: void ColladaUtils::convertTransform(MatrixF& mat)
	Line 50:    MatrixF rot(true);
	Line 667:             MatrixF mat = vecToMatrixF<domMatrix>(con->getSkin()->getBind_shape_matrix()->getValue());
  G:\Torque3D\Engine\source\ts\collada\colladaUtils.h (19 hits)
	Line 120:    void convertTransform(MatrixF& m);
	Line 156: /// Convert from the Collada transform types to a Torque MatrixF
	Line 157: template<class T> inline MatrixF vecToMatrixF(const domListOfFloats& vec) { return MatrixF(true); }
	Line 157: template<class T> inline MatrixF vecToMatrixF(const domListOfFloats& vec) { return MatrixF(true); }
	Line 160: template<> inline MatrixF vecToMatrixF<domTranslate>(const domListOfFloats& vec)
	Line 162:    MatrixF mat(true);
	Line 168: template<> inline MatrixF vecToMatrixF<domScale>(const domListOfFloats& vec)
	Line 170:    MatrixF mat(true);
	Line 176: template<> inline MatrixF vecToMatrixF<domRotate>(const domListOfFloats& vec)
	Line 179:    MatrixF mat(true);
	Line 185: template<> inline MatrixF vecToMatrixF<domMatrix>(const domListOfFloats& vec)
	Line 187:    MatrixF mat;
	Line 195: template<> inline MatrixF vecToMatrixF<domSkew>(const domListOfFloats& vec)
	Line 216:    MatrixF mat(true);
	Line 232: template<> inline MatrixF vecToMatrixF<domLookat>(const domListOfFloats& vec)
	Line 247:    MatrixF mat(true);
	Line 286: // - double to MatrixF
	Line 416:    MatrixF getMatrixFValue(S32 index) const
	Line 418:       MatrixF value(true);
  G:\Torque3D\Engine\source\ts\loader\appMesh.cpp (4 hits)
	Line 46:       Vector<MatrixF> boneTransforms;
	Line 50:          MatrixF nodeMat = bones[iBone]->getNodeTransform( TSShapeLoader::DefaultTime );
	Line 62:          const MatrixF& deltaTransform = boneTransforms[ boneIndex[iWeight] ];
	Line 77:       MatrixF transform = getMeshTransform(TSShapeLoader::DefaultTime);
  G:\Torque3D\Engine\source\ts\loader\appMesh.h (4 hits)
	Line 58:    Vector<MatrixF> initialTransforms;
	Line 69:    MatrixF                       objectOffset;
	Line 85:    virtual MatrixF getMeshTransform(F32 time) = 0;
	Line 102:    virtual void lockMesh(F32 t, const MatrixF& objOffset) { }
  G:\Torque3D\Engine\source\ts\loader\appNode.h (1 hit)
	Line 66:    virtual MatrixF getNodeTransform(F32 time) = 0;
  G:\Torque3D\Engine\source\ts\loader\tsShapeLoader.cpp (15 hits)
	Line 54: void TSShapeLoader::zapScale(MatrixF& mat)
	Line 66: MatrixF TSShapeLoader::getLocalNodeMatrix(AppNode* node, F32 t)
	Line 68:    MatrixF m1 = node->getNodeTransform(t);
	Line 71:    MatrixF m10 = node->getNodeTransform(DefaultTime);
	Line 78:       MatrixF m2 = parent->getNodeTransform(t);
	Line 81:       MatrixF m20 = parent->getNodeTransform(DefaultTime);
	Line 90:       MatrixF mb = boundsNode->getNodeTransform(t);
	Line 101:    MatrixF m1 = getLocalNodeMatrix(node, t);
	Line 104:       MatrixF m0 = getLocalNodeMatrix(node, referenceTime);
	Line 197:       MatrixF boundsMat(boundsNode->getNodeTransform(DefaultTime));
	Line 203:          MatrixF transform = mesh->getMeshTransform(DefaultTime);
	Line 582:          MatrixF meshMat(appMesh->getMeshTransform(DefaultTime));
	Line 583:          MatrixF nodeMat(appMesh->isSkin() ? meshMat : appNode->getNodeTransform(DefaultTime));
	Line 1050:    MatrixF invStartMat = boundsNode->getNodeTransform(appSeq->getStart());
	Line 1059:       MatrixF mat = boundsNode->getNodeTransform(time);
  G:\Torque3D\Engine\source\ts\loader\tsShapeLoader.h (2 hits)
	Line 137:    MatrixF getLocalNodeMatrix(AppNode* node, F32 t);
	Line 191:    static void zapScale(MatrixF& mat);
  G:\Torque3D\Engine\source\ts\tsAnimate.cpp (7 hits)
	Line 604:       MatrixF mat(true);
	Line 920: void TSShapeInstance::addPath(TSThread *gt, F32 start, F32 end, MatrixF *mat)
	Line 928:    MatrixF startInvM;
	Line 932:    MatrixF endM;
	Line 935:    MatrixF addM;
	Line 988: void TSShapeInstance::deltaGround(TSThread * thread, F32 start, F32 end, MatrixF * mat)
	Line 1005: void TSShapeInstance::deltaGround1(TSThread * thread, F32 start, F32 end, MatrixF& mat)
  G:\Torque3D\Engine\source\ts\tsCollision.cpp (43 hits)
	Line 74:       MatrixF initialMat;
	Line 79:       MatrixF mat;
	Line 80:       MatrixF scaleMat(true);
	Line 85:       const MatrixF *previousMat = &mMeshObjects[start].getTransform();
	Line 121: bool TSShapeInstance::getFeatures(const MatrixF& mat, const Point3F& n, ConvexFeature* cf, S32 dl)
	Line 142:       MatrixF final;
	Line 143:       const MatrixF* previousMat = &mMeshObjects[start].getTransform();
	Line 186:    const MatrixF * saveMat = NULL;
	Line 193:       MatrixF mat;
	Line 194:       const MatrixF * previousMat = &mMeshObjects[start].getTransform();
	Line 272:    const MatrixF * saveMat = NULL;
	Line 279:       MatrixF mat;
	Line 280:       const MatrixF * previousMat = &mMeshObjects[start].getTransform();
	Line 354:    const MatrixF * previousMat = NULL;
	Line 355:    MatrixF mat;
	Line 459: bool TSShapeInstance::ObjectInstance::getFeatures(S32 objectDetail, const MatrixF& mat, const Point3F& n, ConvexFeature* cf, U32& surfaceKey)
	Line 495: bool TSShapeInstance::MeshObjectInstance::getFeatures(S32 objectDetail, const MatrixF& mat, const Point3F& n, ConvexFeature* cf, U32& surfaceKey)
	Line 548: bool TSShapeInstance::ObjectInstance::buildConvexOpcode( const MatrixF &mat, S32 objectDetail, const Box3F &bounds, Convex *c, Convex *list )
	Line 575: bool TSShapeInstance::MeshObjectInstance::buildConvexOpcode( const MatrixF &mat, S32 objectDetail, const Box3F &bounds, Convex *c, Convex *list)
	Line 607:       MatrixF initialMat;
	Line 612:       MatrixF mat;
	Line 613:       MatrixF scaleMat(true);
	Line 618:       const MatrixF * previousMat = &mMeshObjects[start].getTransform();
	Line 625:       MatrixF otherMat = mat;
	Line 688:    const MatrixF* saveMat = NULL;
	Line 693:       MatrixF mat;
	Line 694:       const MatrixF * previousMat = &mMeshObjects[start].getTransform();
	Line 743: bool TSShapeInstance::buildConvexOpcode( const MatrixF &objMat, const Point3F &objScale, S32 dl, const Box3F &bounds, Convex *c, Convex *list )
	Line 759:       MatrixF initialMat = objMat;
	Line 763:       MatrixF mat;
	Line 764:       MatrixF scaleMat(true);
	Line 769:       const MatrixF * previousMat = &mMeshObjects[start].getTransform();
	Line 775:       MatrixF otherMat = mat;
	Line 964:       polyList.setTransform( &MatrixF::Identity, scale );
	Line 989:          MatrixF localXfm;
	Line 1045:          MatrixF localXfm;
	Line 1060:             MatrixF centerXfm( true );
	Line 1073:             MatrixF primXfm( true );
	Line 1086:             MatrixF primXfm( true );
	Line 1123:             polyList.setTransform( &MatrixF::Identity, scale );
	Line 1140:             MatrixF meshMat( localXfm );
	Line 1146:             polyList.setTransform( &MatrixF::Identity, scale );
	Line 1239: bool TSMesh::buildConvexOpcode( const MatrixF &meshToObjectMat, const Box3F &nodeBox, Convex *convex, Convex *list )
  G:\Torque3D\Engine\source\ts\tsLastDetail.cpp (6 hits)
	Line 116:    const MatrixF &mat = GFX->getWorldMatrix();
	Line 356:    static const MatrixF topXfm( EulerF( -M_PI_F / 2.0f, 0, 0 ) );
	Line 357:    static const MatrixF bottomXfm( EulerF( M_PI_F / 2.0f, 0, 0 ) );
	Line 359:    MatrixF angMat;
	Line 394:             angMat.mul( MatrixF( EulerF( rotX, 0, 0 ) ),
	Line 395:                         MatrixF( EulerF( 0, 0, rotZ ) ) );
  G:\Torque3D\Engine\source\ts\tsMesh.cpp (17 hits)
	Line 75: Vector<MatrixF*> TSSkinMesh::smInitTransformList;
	Line 93: void tsForceFaceCamera( MatrixF *mat, const Point3F *objScale )
	Line 102:       MatrixF scale( true );
	Line 137:                      const Vector<MatrixF> &transforms, 
	Line 171:    const MatrixF &objToWorld = GFX->getWorldMatrix();
	Line 192:       MatrixF orient = MathUtils::createOrientFromDir(targetVector);
	Line 421: bool TSMesh::getFeatures( S32 frame, const MatrixF& mat, const VectorF&, ConvexFeature* cf, U32& )
	Line 1027:    MatrixF mat(true);
	Line 1031: void TSMesh::computeBounds( const MatrixF &transform, Box3F &bounds, S32 frame, Point3F *center, F32 *radius )
	Line 1066: void TSMesh::computeBounds( const Point3F *v, S32 numVerts, S32 stride, const MatrixF &transform, Box3F &bounds, Point3F *center, F32 *radius )
	Line 1186: void TSSkinMesh::updateSkin( const Vector<MatrixF> &transforms, TSVertexBufferHandle &instanceVB, GFXPrimitiveBufferHandle &instancePB )
	Line 1208:    static Vector<MatrixF> sBoneTransforms;
	Line 1218:    const MatrixF * matrices = &sBoneTransforms[0];
	Line 1247:             const MatrixF& deltaTransform = matrices[transformOp.transformIndex];
	Line 1290:          const MatrixF &curBoneMat = matrices[boneXfmIdx];
	Line 1490:                            const Vector<MatrixF> &transforms, 
	Line 1555: void TSSkinMesh::computeBounds( const MatrixF &transform, Box3F &bounds, S32 frame, Point3F *center, F32 *radius )
  G:\Torque3D\Engine\source\ts\tsMesh.h (10 hits)
	Line 287:                         const Vector<MatrixF> &transforms, 
	Line 305:    virtual bool getFeatures( S32 frame, const MatrixF&, const VectorF&, ConvexFeature*, U32 &surfaceKey );
	Line 318:    virtual void computeBounds( const MatrixF &transform, Box3F &bounds, S32 frame = 0, Point3F *center = NULL, F32 *radius = NULL );
	Line 319:    void computeBounds( const Point3F *, S32 numVerts, S32 stride, const MatrixF &transform, Box3F &bounds, Point3F *center, F32 *radius );
	Line 401:    bool buildConvexOpcode( const MatrixF &mat, const Box3F &bounds, Convex *c, Convex *list );
	Line 488:       Vector<MatrixF> initialTransforms;
	Line 513:    void updateSkin( const Vector<MatrixF> &transforms, TSVertexBufferHandle &instanceVB, GFXPrimitiveBufferHandle &instancePB );
	Line 520:                   const Vector<MatrixF> &transforms, 
	Line 529:    void computeBounds( const MatrixF &transform, Box3F &bounds, S32 frame, Point3F *center, F32 *radius );
	Line 537:    static Vector<MatrixF*> smInitTransformList;
  G:\Torque3D\Engine\source\ts\tsMeshFit.cpp (12 hits)
	Line 88:    MatrixF     mBoxTransform;
	Line 94:    MatrixF     mCapTransform;
	Line 142:       MatrixF     transform;
	Line 173:    void addBox( const Point3F& sides, const MatrixF& mat );
	Line 181:    void addCapsule( F32 radius, F32 height, const MatrixF& mat );
	Line 298:    MatrixF objMat;
	Line 403: void MeshFit::addBox( const Point3F& sides, const MatrixF& mat )
	Line 462: void MeshFit::addCapsule( F32 radius, F32 height, const MatrixF& mat )
	Line 751:          fit.addBox( sides, MatrixF::Identity );
	Line 771:          fit.addCapsule( radius, height, MatrixF::Identity );
	Line 784:    MatrixF mat( txfm.getMatrix() );
	Line 900:       MatrixF mat;
  G:\Torque3D\Engine\source\ts\tsMeshIntrinsics.cpp (3 hits)
	Line 29: void (*m_matF_x_BatchedVertWeightList)(const MatrixF &mat, const dsize_t count, const TSSkinMesh::BatchData::BatchedVertWeight * __restrict batch, U8 * const __restrict outPtr, const dsize_t outStride) = NULL;
	Line 52: void m_matF_x_BatchedVertWeightList_C(const MatrixF &mat, 
	Line 58:    const register MatrixF m = mat;
  G:\Torque3D\Engine\source\ts\tsMeshIntrinsics.h (1 hit)
	Line 34:                                    (const MatrixF &mat, 
  G:\Torque3D\Engine\source\ts\tsPartInstance.cpp (1 hit)
	Line 279:    MatrixF toCam = GFX->getWorldMatrix();
  G:\Torque3D\Engine\source\ts\tsShape.cpp (6 hits)
	Line 332: void TSShape::getNodeWorldTransform(S32 nodeIndex, MatrixF* mat) const
	Line 347:          MatrixF mat2(*mat);
	Line 734: Vector<MatrixF> gTempNodeTransforms(__FILE__, __LINE__);
	Line 761:       MatrixF mat;
	Line 782:          static MatrixF idMat(true);
	Line 2075:    MatrixF mat(true);
  G:\Torque3D\Engine\source\ts\tsShape.h (2 hits)
	Line 515:    void getNodeWorldTransform(S32 nodeIndex, MatrixF* mat) const;
	Line 516:    void getNodeKeyframe(S32 nodeIndex, const TSShape::Sequence& seq, S32 keyframe, MatrixF* mat) const;
  G:\Torque3D\Engine\source\ts\tsShapeConstruct.cpp (4 hits)
	Line 879:       MatrixF mat;
	Line 923:          MatrixF mat;
	Line 992:          MatrixF mat;
	Line 1803:       MatrixF mat;
  G:\Torque3D\Engine\source\ts\tsShapeEdit.cpp (4 hits)
	Line 1964: void TSShape::getNodeKeyframe(S32 nodeIndex, const TSShape::Sequence& seq, S32 keyframe, MatrixF* mat) const
	Line 2034:       MatrixF refMat;
	Line 2056:          MatrixF oldMat;
	Line 2059:          MatrixF newMat;
  G:\Torque3D\Engine\source\ts\tsShapeInstance.cpp (3 hits)
	Line 96: Vector<MatrixF>               TSShapeInstance::smNodeLocalTransforms(__FILE__, __LINE__);
	Line 360:       const MatrixF &meshMat = meshObj->getTransform();
	Line 733:    const MatrixF &transform = getTransform();
  G:\Torque3D\Engine\source\ts\tsShapeInstance.h (18 hits)
	Line 64:    virtual void setNodeTransform(TSShapeInstance * si, S32 nodeIndex, MatrixF & localTransform) = 0;
	Line 115:       const Vector<MatrixF> *mTransforms;
	Line 120:       inline const MatrixF& getTransform() const
	Line 122:          return nodeIndex < 0 ? MatrixF::Identity : (*mTransforms)[ nodeIndex ];
	Line 136:       virtual bool getFeatures( S32 objectDetail, const MatrixF &mat, const Point3F &n, ConvexFeature *feature, U32 &surfaceKey );
	Line 141:       virtual bool buildConvexOpcode( const MatrixF &mat, S32 objectDetail, const Box3F &bounds, Convex *c, Convex *list );
	Line 180:       bool getFeatures( S32 objectDetail, const MatrixF &mat, const Point3F &n, ConvexFeature *feature, U32 &surfaceKey );
	Line 187:       bool buildConvexOpcode( const MatrixF &mat, S32 objectDetail, const Box3F &bounds, Convex *c, Convex *list );
	Line 209:    Vector<MatrixF> mNodeTransforms;
	Line 228:    static Vector<MatrixF> smNodeLocalTransforms;
	Line 249:    MatrixF mGroundTransform;
	Line 314:    void addPath(TSThread * gt, F32 start, F32 end, MatrixF * mat = NULL);
	Line 529:    MatrixF & getGroundTransform() { return mGroundTransform; }
	Line 530:    void deltaGround(TSThread *, F32 start, F32 end, MatrixF * mat = NULL);
	Line 531:    void deltaGround1(TSThread *, F32 start, F32 end, MatrixF& mat);
	Line 576:    bool getFeatures(const MatrixF& mat, const Point3F& n, ConvexFeature*, S32 dl);
	Line 586:    bool buildConvexOpcode( const MatrixF &objMat, const Point3F &objScale, S32 objectDetail, const Box3F &bounds, Convex *c, Convex *list );
	Line 749:    void getGround(F32 p, MatrixF * pMat);
  G:\Torque3D\Engine\source\ts\tsThread.cpp (1 hit)
	Line 115: void TSThread::getGround(F32 t, MatrixF * pMat)
  G:\Torque3D\Engine\source\ts\tsTransform.cpp (5 hits)
	Line 137: void TSTransform::applyScale(F32 scale, MatrixF * mat)
	Line 142: void TSTransform::applyScale(const Point3F & scale, MatrixF * mat)
	Line 147: void TSTransform::applyScale(const TSScale & scale, MatrixF * mat)
	Line 149:    MatrixF mat2;
	Line 151:    MatrixF mat3(mat2);
  G:\Torque3D\Engine\source\ts\tsTransform.h (7 hits)
	Line 70:    static void      setMatrix(const QuatF     &  q, MatrixF *);
	Line 71:    static void      setMatrix(const QuatF     &  q, const Point3F & p, MatrixF *);
	Line 73:    static void      applyScale(F32 scale, MatrixF *);
	Line 74:    static void      applyScale(const Point3F & scale, MatrixF *);
	Line 75:    static void      applyScale(const TSScale & scale, MatrixF *);
	Line 98: inline void TSTransform::setMatrix( const QuatF & q, const Point3F & p, MatrixF * pDest )
	Line 104: inline void TSTransform::setMatrix( const QuatF & q, MatrixF * pDest )
  G:\Torque3D\Engine\source\util\imposterCapture.cpp (5 hits)
	Line 394:    MatrixF cameraMatrix( true );
	Line 440: void ImposterCapture::capture(   const MatrixF &rotMatrix, 
	Line 455:    MatrixF centerMat( true );
	Line 457:    MatrixF objMatrix( rotMatrix );
	Line 462:    MatrixF view( EulerF( M_PI_F / 2.0f, 0, M_PI_F ), Point3F( 0, 0, -10.0f * mRadius ) );
  G:\Torque3D\Engine\source\util\imposterCapture.h (1 hit)
	Line 103:    void capture(  const MatrixF &rotMatrix, 
